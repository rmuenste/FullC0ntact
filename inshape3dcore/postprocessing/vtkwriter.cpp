#include "vtkwriter.h"
#include <iostream>
#include <fstream>
#include <aabb3.h>
#include <obb3.h>
#include <triangulator.h>
#include <cylinder.h>
#include <sstream>
#include <iomanip>
#include <meshobject.h>

namespace i3d {

CVtkWriter::CVtkWriter(void)
{
}

CVtkWriter::~CVtkWriter(void)
{
}

void CVtkWriter::WriteUnstr(CUnstrGrid &Grid,const char *strFileName)
{
  
  using namespace std;
  FILE * myfile = fopen(strFileName,"w");

  if (myfile == NULL) {
    cout<<"Error opening file: "<<strFileName<<endl;
    exit(0);
  }  
    
  int i,j;
  fprintf(myfile,"# vtk DataFile Version 2.0\n");
  fprintf(myfile,"Generated by FullC0ntact\n");
  fprintf(myfile,"ASCII\n");
  fprintf(myfile,"DATASET UNSTRUCTURED_GRID\n");
  fprintf(myfile,"POINTS %i double\n",Grid.m_iNVT);      

  //fprintf(myfile,"3 %i %i %i \n",pMesh.m_pFaces[i][0]+ioffset, pMesh.m_pFaces[i][1]+ioffset, pMesh.m_pFaces[i][2]+ioffset);  
  
  for(i=0;i<Grid.m_iNVT;i++)
  {
    fprintf(myfile,"%f %f %f \n",Grid.m_pVertexCoords[i].x,Grid.m_pVertexCoords[i].y,Grid.m_pVertexCoords[i].z);    
  }//end for

  fprintf(myfile,"CELLS %i %i\n",Grid.m_iNEL,Grid.m_iNEL*9);
  for(i=0;i<Grid.m_iNEL;i++)
  {
    fprintf(myfile,"8  %i %i %i %i %i %i %i %i\n",Grid.m_pHexas[i].m_iVertInd[0],Grid.m_pHexas[i].m_iVertInd[1],Grid.m_pHexas[i].m_iVertInd[2],
                                                  Grid.m_pHexas[i].m_iVertInd[3],Grid.m_pHexas[i].m_iVertInd[4],Grid.m_pHexas[i].m_iVertInd[5],
                                                  Grid.m_pHexas[i].m_iVertInd[6],Grid.m_pHexas[i].m_iVertInd[7]);    
  }//end for
  
  fprintf(myfile,"CELL_TYPES %i\n",Grid.m_iNEL);        
  for(i=0;i<Grid.m_iNEL;i++)
  {
    fprintf(myfile,"12\n");          
  }//end for

  fprintf(myfile,"POINT_DATA %i\n",Grid.m_iNVT);
  fprintf(myfile,"SCALARS distance double 1\n");
  fprintf(myfile,"LOOKUP_TABLE default\n");      
  for(int i=0;i<Grid.m_iNVT;i++)
  {
    fprintf(myfile,"%f \n",Grid.m_myTraits[i].distance);      
  }//end for

  fprintf(myfile,"SCALARS inout int 1\n");
  fprintf(myfile,"LOOKUP_TABLE default\n");    
  for(int i=0;i<Grid.m_iNVT;i++)
  {
    fprintf(myfile,"%i\n",Grid.m_myTraits[i].iTag);        
  }//end for
  
  fprintf(myfile,"VECTORS Normal double\n");  
  for(int i=0;i<Grid.m_iNVT;i++)
  {
    fprintf(myfile,"%f %f %f\n",Grid.m_myTraits[i].vNormal.x,Grid.m_myTraits[i].vNormal.y,Grid.m_myTraits[i].vNormal.z);    
  }//end for  

  fprintf(myfile,"CELL_DATA %i\n",Grid.m_iNEL);
  fprintf(myfile,"SCALARS dummy2 double 1\n");    
  fprintf(myfile,"LOOKUP_TABLE default\n");      
  for(int k=0;k<Grid.m_iNEL;k++)
  {
    fprintf(myfile,"-1\n");
  }//end for

  //close the file
  fclose (myfile);  
  
}

void CVtkWriter::WriteParamLine(CParamLiner& line, const char* strFileName)
{
  using namespace std;
  ofstream myfile(strFileName);

  //check
  if(!myfile.is_open())
  {
  cout<<"Error opening file: "<<"output.vtk"<<endl;
  exit(0);
  }//end if

  int i,j;
  myfile<<"# vtk DataFile Version 2.0"<<endl;
  myfile<<"Generated by InShape 2.x"<<endl;
  myfile<<"ASCII"<<endl;
  myfile<<"DATASET UNSTRUCTURED_GRID"<<endl;
  myfile<<"POINTS "<<line.m_pVertices.size()<<" double"<<endl;
  myfile.precision(7);
  
  int iVerts = line.m_pVertices.size();
  
  for(i=0;i<iVerts;i++)
  {
  myfile<<line.m_pVertices[i].x<<" "<<line.m_pVertices[i].y<<" "<<line.m_pVertices[i].z<<endl;
  }//end for
  myfile.precision();
  
  int iCells = line.m_pSegments.size();
  myfile<<"CELLS "<<iCells<<" "<<iCells*3<<endl;
  
  for(i=0;i<iCells;i++)
  {
    myfile <<2<<" "<<line.m_vFaces[i].first<<" "<<line.m_vFaces[i].second<<" "<<endl;
  }//end for
  
  myfile<<"CELL_TYPES "<<iCells<<endl;
  for(i=0;i<iCells;i++)
  {
    myfile<<3<<endl;
  }//end for

  //close the file
  myfile.close();

}

void CVtkWriter::WriteUnstr(CUnstrGrid &Grid,std::vector<Real> &element,const char *strFileName)
{
  using namespace std;
  ofstream myfile(strFileName);

  //check
  if(!myfile.is_open())
  {
  cout<<"Error opening file: "<<"output.vtk"<<endl;
  exit(0);
  }//end if
  int asdf=element.size();
  int i,j;
  myfile<<"# vtk DataFile Version 2.0"<<endl;
  myfile<<"Generated by InShape 2.x"<<endl;
  myfile<<"ASCII"<<endl;
  myfile<<"DATASET UNSTRUCTURED_GRID"<<endl;
  myfile<<"POINTS "<<Grid.m_iNVT<<" double"<<endl;
  myfile.precision(7);
  for(i=0;i<Grid.m_iNVT;i++)
  {
  myfile<<Grid.m_pVertexCoords[i].x<<" "<<Grid.m_pVertexCoords[i].y<<" "<<Grid.m_pVertexCoords[i].z<<endl;
  }//end for
  myfile.precision();
  myfile<<"CELLS "<<Grid.m_iNEL<<" "<<Grid.m_iNEL*9<<endl;
  for(i=0;i<Grid.m_iNEL;i++)
  {
  myfile <<8<<" ";
  for(j=0;j<8;j++)
    myfile<<Grid.m_pHexas[i].m_iVertInd[j]<<" ";
  myfile<<endl;
  }//end for
  myfile<<"CELL_TYPES "<<Grid.m_iNEL<<endl;
  for(i=0;i<Grid.m_iNEL;i++)
  {
  myfile<<12<<endl;
  }//end for

  myfile<<"POINT_DATA "<<Grid.m_iNVT<<endl;
  myfile<<"SCALARS "<<"distance double 1"<<endl;
  myfile<<"LOOKUP_TABLE default"<<endl;
  for(int i=0;i<Grid.m_iNVT;i++)
  {
  myfile<<Grid.m_myTraits[i].distance<<endl;
  }//end for

  myfile<<"SCALARS "<<"inout int 1"<<endl;
  myfile<<"LOOKUP_TABLE default"<<endl;
  for(int i=0;i<Grid.m_iNVT;i++)
  {
  myfile<<Grid.m_myTraits[i].iTag<<endl;
  }//end for
  
  myfile<<"VECTORS Normal double"<<endl;
  for(int i=0;i<Grid.m_iNVT;i++)
  {
  myfile<<Grid.m_myTraits[i].vNormal<<endl;
  }//end for


  myfile<<"CELL_DATA "<<Grid.m_iNEL<<endl;
  myfile<<"SCALARS "<<"dummy2 double 1"<<endl;
  myfile<<"LOOKUP_TABLE default"<<endl;
  for(int k=0;k<Grid.m_iNEL;k++)
  {
    myfile<<element[k]<<endl;
  }//end for

  //close the file
  myfile.close();

}

void CVtkWriter::WriteModel(C3DModel &pModel,const char *strFileName)
{
  using namespace std;
  ofstream myfile(strFileName);

  //check
  if(!myfile.is_open())
  {
	cout<<"Error opening file: "<<strFileName<<endl;
	exit(0);
  }//end if
  
  int iVerts=0;
  int iPolys=0;
  vector<C3DMesh>::iterator mIter;
	int icount = 0;
  for(mIter=pModel.m_vMeshes.begin();mIter!=pModel.m_vMeshes.end();mIter++)
  {
	C3DMesh &pMesh=*mIter;
	iVerts+=pMesh.m_iNumVerts;
	iPolys+=pMesh.m_iNumFaces;
	icount++;
  }
  myfile<<"# vtk DataFile Version 2.0"<<endl;
  myfile<<"Generated by InShape 2.x"<<endl;
  myfile<<"ASCII"<<endl;
  myfile<<"DATASET POLYDATA"<<endl;
  myfile<<"POINTS "<<iVerts<<" double"<<endl;
  myfile.precision(7);
	icount = 0;
  for(mIter=pModel.m_vMeshes.begin();mIter!=pModel.m_vMeshes.end();mIter++)
  {
	C3DMesh &pMesh=*mIter;
	for(int i=0;i<pMesh.m_pVertices.Size();i++)
	{
	  myfile<<pMesh.m_pVertices[i].x<<" "<<pMesh.m_pVertices[i].y<<" "<<pMesh.m_pVertices[i].z<<endl;
	}//end for
		icount++;
  }//for
  int lengthPolyList=4*iPolys;
  myfile<<"POLYGONS "<<iPolys<<" "<<lengthPolyList<<endl;
	icount = 0;
  for(mIter=pModel.m_vMeshes.begin();mIter!=pModel.m_vMeshes.end();mIter++)
  {
	C3DMesh &pMesh=*mIter;
	for(int i=0;i<pMesh.m_iNumFaces;i++)
	{
		myfile<<3<<" "<<pMesh.m_pFaces[i][0]+icount*pMesh.NumVertices()
					<<" "<<pMesh.m_pFaces[i][1]+icount*pMesh.NumVertices()
					<<" "<<pMesh.m_pFaces[i][2]+icount*pMesh.NumVertices()<<endl;
	}//end for
	icount++;
  }//for  

}//end


void CVtkWriter::WriteRigidBodiesEx(std::vector<COBB3r*> &pRigidBodies,const char *strFileName)
{
	using namespace std;
	FILE * myfile = fopen(strFileName,"w");

	if (myfile == NULL) {
		cout<<"Error opening file: "<<strFileName<<endl;
		exit(0);
	}

	//total number of vertices
	int iVerts=0;
	//total number of polygons
	int iPolys=0;
	//iterators for models and submeshes
	vector<C3DMesh>::iterator meshIter;
	vector<C3DModel>::iterator modelIter;
	vector<COBB3r*>::iterator rIter;
	vector<C3DModel> pModels;
	vector<int> vVerts;
	vector<int>::iterator vertsIter;
	int ioffset=0;
	
	for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
	{

	  CTriangulator<Real, COBB3<Real> > triangulator;
	  COBB3r *pBox = *rIter;
	  C3DModel model_out=triangulator.Triangulate(*pBox);
	  pModels.push_back(model_out);
	}	

	for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
	{
		C3DModel &pModel = *modelIter;
		int ivertsModel=0;
		for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
		{
			C3DMesh &pMesh=*meshIter;
			iVerts+=pMesh.m_iNumVerts;
			iPolys+=pMesh.m_iNumFaces;
			ivertsModel+=pMesh.m_iNumVerts;
		}
		vVerts.push_back(ivertsModel);
	}

	fprintf(myfile,"# vtk DataFile Version 2.0\n");
	fprintf(myfile,"Generated by InShape 2.x\n");
	fprintf(myfile,"ASCII\n");
	fprintf(myfile,"DATASET POLYDATA\n");
	fprintf(myfile,"POINTS %i double\n",iVerts);

	//write the actual vertex data
	for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
	{
		C3DModel &pModel = *modelIter;
		for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
		{
		C3DMesh &pMesh=*meshIter;
		for(int i=0;i<pMesh.m_pVertices.Size();i++)
		{
			fprintf(myfile,"%f %f %f \n",pMesh.m_pVertices[i].x,pMesh.m_pVertices[i].y,pMesh.m_pVertices[i].z);
		}//end for
		}//for
	}//end for

	int lengthPolyList=4*iPolys;
	fprintf(myfile,"POLYGONS %i %i \n",iPolys,lengthPolyList);
	vertsIter = vVerts.begin();
	for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
	{
		C3DModel &pModel = *modelIter;
		int ivertsModel = *vertsIter;
		for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
		{
		C3DMesh &pMesh=*meshIter;
			for(int i=0;i<pMesh.m_iNumFaces;i++)
			{
				fprintf(myfile,"3 %i %i %i \n",pMesh.m_pFaces[i][0]+ioffset, pMesh.m_pFaces[i][1]+ioffset, pMesh.m_pFaces[i][2]+ioffset);
			}//end for faces
		}//for submeshes
		ioffset+=ivertsModel;
		vertsIter++;
	}//for models

	fprintf(myfile,"POINT_DATA %i \n",iVerts);
	fprintf(myfile,"SCALARS dummy double 1 \n");
	fprintf(myfile,"LOOKUP_TABLE default\n");
	int modelid=0;
	for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
	{
		C3DModel &pModel = *modelIter;
		for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
		{
		C3DMesh &pMesh=*meshIter;
			for(int i=0;i<pMesh.m_pVertices.Size();i++)
			{
				fprintf(myfile,"%f\n",(pMesh.m_pVertices[0]-pMesh.m_pVertices[i]).mag());
			}//end for
		}//for
		modelid++;
	}//end for
	fprintf(myfile,"CELL_DATA %i \n",iPolys);
	fprintf(myfile,"SCALARS CellID int 1\n");
	fprintf(myfile,"LOOKUP_TABLE default\n");
	int cellid=0;
	for(modelIter = pModels.begin(),rIter=pRigidBodies.begin();modelIter!=pModels.end();modelIter++,rIter++)
	{
		C3DModel &pModel = *modelIter;
		for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
		{
		C3DMesh &pMesh=*meshIter;
			for(int i=0;i<pMesh.m_iNumFaces;i++)
			{
				fprintf(myfile,"%i \n",cellid);
			}//end for faces
		}//for submeshes
		cellid++;
	}//for models

	fclose (myfile);

}

void CVtkWriter::WriteSolids(std::vector<C3DModel> &pSolids,const char *strFileName)
{
	using namespace std;
	ofstream myfile(strFileName);

	//total number of vertices
	int iVerts=0;
	//total number of polygons
	int iPolys=0;
	//iterators for models and submeshes
	vector<C3DMesh>::iterator meshIter;
	vector<C3DModel>::iterator modelIter;
	vector<int> vVerts;
	vector<int>::iterator vertsIter;
	int ioffset=0;

	//check
	if(!myfile.is_open())
	{
	cout<<"Error opening file: "<<strFileName<<endl;
	exit(0);
	}//end if

	for(modelIter = pSolids.begin();modelIter!=pSolids.end();modelIter++)
	{
		C3DModel &pModel = *modelIter;
		int ivertsModel=0;
		for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
		{
			C3DMesh &pMesh=*meshIter;
			iVerts+=pMesh.m_iNumVerts;
			iPolys+=pMesh.m_iNumFaces;
			ivertsModel+=pMesh.m_iNumVerts;
		}
		vVerts.push_back(ivertsModel);
	}

	myfile<<"# vtk DataFile Version 2.0"<<endl;
	myfile<<"Generated by InShape 2.x"<<endl;
	myfile<<"ASCII"<<endl;
	myfile<<"DATASET POLYDATA"<<endl;
	myfile<<"POINTS "<<iVerts<<" double"<<endl;
	myfile.precision(7);
	//write the actual vertex data
	for(modelIter = pSolids.begin();modelIter!=pSolids.end();modelIter++)
	{
		C3DModel &pModel = *modelIter;
		for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
		{
		C3DMesh &pMesh=*meshIter;
		for(int i=0;i<pMesh.m_pVertices.Size();i++)
		{
			myfile<<pMesh.m_pVertices[i].x<<" "<<pMesh.m_pVertices[i].y<<" "<<pMesh.m_pVertices[i].z<<endl;
		}//end for
		}//for
	}//end for

	int lengthPolyList=4*iPolys;
	myfile<<"POLYGONS "<<iPolys<<" "<<lengthPolyList<<endl;
	vertsIter = vVerts.begin();
	for(modelIter = pSolids.begin();modelIter!=pSolids.end();modelIter++)
	{
		C3DModel &pModel = *modelIter;
		int ivertsModel = *vertsIter;
		for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
		{
		C3DMesh &pMesh=*meshIter;
			for(int i=0;i<pMesh.m_iNumFaces;i++)
			{
				myfile<<3<<" "<<pMesh.m_pFaces[i][0]+ioffset<<" "
					<<pMesh.m_pFaces[i][1]+ioffset<<" "<<pMesh.m_pFaces[i][2]+ioffset<<endl;
			}//end for faces
		}//for submeshes
		ioffset+=ivertsModel;
		vertsIter++;
	}//for models
	myfile.close();
}

void CVtkWriter::WriteRigidBodies(std::vector<RigidBody*> &pRigidBodies,const char *strFileName)
{
  using namespace std;
  FILE * myfile = fopen(strFileName,"w");

  if (myfile == NULL) {
    cout<<"Error opening file: "<<strFileName<<endl;
    exit(0);
  }

  //total number of vertices
  int iVerts=0;
  //total number of polygons
  int iPolys=0;
  //iterators for models and submeshes
  vector<C3DMesh>::iterator meshIter;
  vector<C3DModel>::iterator modelIter;
  vector<RigidBody*>::iterator rIter;
  vector<C3DModel> pModels;
  vector<int> vVerts;
  vector<int>::iterator vertsIter;
  int ioffset=0;

  for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
  {
    RigidBody &body = *(*rIter);
    if(body.shapeId_ == RigidBody::BOX)
    {
      CTriangulator<Real, COBB3<Real> > triangulator;
      COBB3r *pBox = dynamic_cast<COBB3r*>(body.shape_);
      C3DModel model_out=triangulator.Triangulate(*pBox);
      model_out.m_vMeshes[0].m_matTransform = body.getTransformationMatrix();
      model_out.m_vMeshes[0].m_vOrigin =body.com_;
      model_out.m_vMeshes[0].TransformModelWorld();
      pModels.push_back(model_out);
    }
    else if(body.shapeId_ == RigidBody::SPHERE)
    {
      CTriangulator<Real, CSphere<Real> > triangulator;
      CSpherer *pSphere = dynamic_cast<CSpherer*>(body.shape_);
      C3DModel model_out=triangulator.Triangulate(*pSphere);
      model_out.m_vMeshes[0].m_matTransform =body.getTransformationMatrix();
      model_out.m_vMeshes[0].m_vOrigin =body.com_;
      model_out.m_vMeshes[0].TransformModelWorld();
      pModels.push_back(model_out);
    }
    else if(body.shapeId_ == RigidBody::CYLINDER)
    {
      CTriangulator<Real, Cylinder<Real> > triangulator;
      Cylinderr *pCylinder = dynamic_cast<Cylinderr*>(body.shape_);
      C3DModel model_out=triangulator.Triangulate(*pCylinder);
      model_out.m_vMeshes[0].m_matTransform =body.getTransformationMatrix();
      model_out.m_vMeshes[0].m_vOrigin =body.com_;
      model_out.m_vMeshes[0].TransformModelWorld();
      pModels.push_back(model_out);
    }
    else if(body.shapeId_ == RigidBody::MESH)
    {
      CMeshObject<Real> *pMeshObject = dynamic_cast<CMeshObject<Real>*>(body.shape_);
      C3DModel model_out=pMeshObject->m_Model;
      //actually loop over all meshes and transform them
      for(int imesh=0;imesh < model_out.m_vMeshes.size();imesh++)
      {
        model_out.m_vMeshes[imesh].m_matTransform =body.getTransformationMatrix();
        model_out.m_vMeshes[imesh].m_vOrigin =body.com_;
        model_out.m_vMeshes[imesh].TransformModelWorld();
      }
      pModels.push_back(model_out);

  //       //if the mesh has a bvh call the writetree level method
  //       if(pMeshObject->m_BVH.GetNumChildren()!=0)
  //       {
  //         int depth = pMeshObject->m_BVH.GetDepth();
  //         for(int level=0;level<depth;level++)
  //         {
  //           std::vector<CBoundingVolumeNode3<CAABB3r,Real,CTraits> *> vec=
  //           pMeshObject->m_BVH.GetNodesLevel(level);
  // 
  //           std::ostringstream sName;
  //           std::string sModel(strFileName);
  //           sName<<".level"<<level;
  //           sModel.append(sName.str());
  //           WriteTreeLevel(vec,sModel.c_str());
  //         }
  //       }
      
    }
  }

  for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
  {
    C3DModel &pModel = *modelIter;
    int ivertsModel=0;
    for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
    {
      C3DMesh &pMesh=*meshIter;
      iVerts+=pMesh.m_iNumVerts;
      iPolys+=pMesh.m_iNumFaces;
      ivertsModel+=pMesh.m_iNumVerts;
    }
    vVerts.push_back(ivertsModel);
  }

  fprintf(myfile,"# vtk DataFile Version 2.0\n");
  fprintf(myfile,"Generated by InShape 2.x\n");
  fprintf(myfile,"ASCII\n");
  fprintf(myfile,"DATASET POLYDATA\n");
  fprintf(myfile,"POINTS %i double\n",iVerts);

  //write the actual vertex data
  for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
  {
    C3DModel &pModel = *modelIter;
    for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
    {
    C3DMesh &pMesh=*meshIter;
    for(int i=0;i<pMesh.m_pVertices.Size();i++)
    {
      fprintf(myfile,"%f %f %f \n",pMesh.m_pVertices[i].x,pMesh.m_pVertices[i].y,pMesh.m_pVertices[i].z);
    }//end for
    }//for
  }//end for

  int lengthPolyList=4*iPolys;
  fprintf(myfile,"POLYGONS %i %i \n",iPolys,lengthPolyList);
  vertsIter = vVerts.begin();
  for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
  {
    C3DModel &pModel = *modelIter;
    int ivertsModel = *vertsIter;
    for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
    {
      C3DMesh &pMesh=*meshIter;
      for(int i=0;i<pMesh.m_iNumFaces;i++)
      {
        fprintf(myfile,"3 %i %i %i \n",pMesh.m_pFaces[i][0]+ioffset, pMesh.m_pFaces[i][1]+ioffset, pMesh.m_pFaces[i][2]+ioffset);
      }//end for faces
      ioffset+=pMesh.m_iNumVerts;
    }//for submeshes
    vertsIter++;
  }//for models

  fprintf(myfile,"POINT_DATA %i \n",iVerts);
  fprintf(myfile,"SCALARS dummy double 1 \n");
  fprintf(myfile,"LOOKUP_TABLE default\n");
  int modelid=0;
  for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
  {
    C3DModel &pModel = *modelIter;
    for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
    {
    C3DMesh &pMesh=*meshIter;
      for(int i=0;i<pMesh.m_pVertices.Size();i++)
      {
        fprintf(myfile,"%f\n",(pMesh.m_pVertices[0]-pMesh.m_pVertices[i]).mag());
      }//end for
    }//for
    modelid++;
  }//end for
  fprintf(myfile,"CELL_DATA %i \n",iPolys);
  fprintf(myfile,"SCALARS CellID int 1\n");
  fprintf(myfile,"LOOKUP_TABLE default\n");
  int cellid=0;
  for(modelIter = pModels.begin(),rIter=pRigidBodies.begin();modelIter!=pModels.end();modelIter++,rIter++)
  {
    RigidBody &body = *(*rIter);
    C3DModel &pModel = *modelIter;
    for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
    {
    C3DMesh &pMesh=*meshIter;
      for(int i=0;i<pMesh.m_iNumFaces;i++)
      {
        fprintf(myfile,"%i \n",cellid);
      }//end for faces
    }//for submeshes
    cellid++;
  }//for models

  fprintf(myfile,"SCALARS ContactGroup int 1\n");
  fprintf(myfile,"LOOKUP_TABLE default\n");
  for(modelIter = pModels.begin(),rIter=pRigidBodies.begin();modelIter!=pModels.end();modelIter++,rIter++)
  {
    RigidBody &body = *(*rIter);
    C3DModel &pModel = *modelIter;
    for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
    {
    C3DMesh &pMesh=*meshIter;
      for(int i=0;i<pMesh.m_iNumFaces;i++)
      {
        fprintf(myfile,"%i \n",body.group_);
      }//end for faces
    }//for submeshes
    cellid++;
  }//for models

  fprintf(myfile,"SCALARS StackHeight int 1\n");
  fprintf(myfile,"LOOKUP_TABLE default\n");
  for(modelIter = pModels.begin(),rIter=pRigidBodies.begin();modelIter!=pModels.end();modelIter++,rIter++)
  {
    RigidBody &body = *(*rIter);
    C3DModel &pModel = *modelIter;
    for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
    {
    C3DMesh &pMesh=*meshIter;
      for(int i=0;i<pMesh.m_iNumFaces;i++)
      {
        fprintf(myfile,"%i \n",body.height_);
      }//end for faces
    }//for submeshes
    cellid++;
  }//for models	

  fclose (myfile);

}

void CVtkWriter::WriteBodiesAsUnstructured(std::vector<RigidBody*> &pRigidBodies,const char *strFileName)
{

  using namespace std;
  FILE * myfile = fopen(strFileName,"w");

  if (myfile == NULL) {
    cout<<"Error opening file: "<<strFileName<<endl;
    exit(0);
  }

  //total number of vertices
  int iVerts=0;
  //total number of polygons
  int iPolys=0;
  //iterators for models and submeshes
  vector<C3DMesh>::iterator meshIter;
  vector<C3DModel>::iterator modelIter;
  vector<RigidBody*>::iterator rIter;
  vector<C3DModel> pModels;
  vector<int> vVerts;
  vector<int>::iterator vertsIter;
  int ioffset=0;

  for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
  {
    RigidBody &body = *(*rIter);
    if(body.shapeId_ == RigidBody::BOX)
    {
      CTriangulator<Real, COBB3<Real> > triangulator;
      COBB3r *pBox = dynamic_cast<COBB3r*>(body.shape_);
      C3DModel model_out=triangulator.Triangulate(*pBox);
      model_out.m_vMeshes[0].m_matTransform = body.getTransformationMatrix();
      model_out.m_vMeshes[0].m_vOrigin =body.com_;
      model_out.m_vMeshes[0].TransformModelWorld();
      pModels.push_back(model_out);
    }
    else if(body.shapeId_ == RigidBody::SPHERE)
    {
      CTriangulator<Real, CSphere<Real> > triangulator;
      CSpherer *pSphere = dynamic_cast<CSpherer*>(body.shape_);
      C3DModel model_out=triangulator.Triangulate(*pSphere);
      model_out.m_vMeshes[0].m_matTransform =body.getTransformationMatrix();
      model_out.m_vMeshes[0].m_vOrigin =body.com_;
      model_out.m_vMeshes[0].TransformModelWorld();
      pModels.push_back(model_out);
    }
    else if(body.shapeId_ == RigidBody::CYLINDER)
    {
      CTriangulator<Real, Cylinder<Real> > triangulator;
      Cylinderr *pCylinder = dynamic_cast<Cylinderr*>(body.shape_);
      C3DModel model_out=triangulator.Triangulate(*pCylinder);
      model_out.m_vMeshes[0].m_matTransform =body.getTransformationMatrix();
      model_out.m_vMeshes[0].m_vOrigin =body.com_;
      model_out.m_vMeshes[0].TransformModelWorld();
      pModels.push_back(model_out);
    }
    else if(body.shapeId_ == RigidBody::MESH)
    {
      CMeshObject<Real> *pMeshObject = dynamic_cast<CMeshObject<Real>*>(body.shape_);
      C3DModel model_out=pMeshObject->m_Model;
      //actually loop over all meshes and transform them
      for(int imesh=0;imesh < model_out.m_vMeshes.size();imesh++)
      {
        model_out.m_vMeshes[imesh].m_matTransform =body.getTransformationMatrix();
        model_out.m_vMeshes[imesh].m_vOrigin =body.com_;
        model_out.m_vMeshes[imesh].TransformModelWorld();
      }
      pModels.push_back(model_out);

  //       //if the mesh has a bvh call the writetree level method
  //       if(pMeshObject->m_BVH.GetNumChildren()!=0)
  //       {
  //         int depth = pMeshObject->m_BVH.GetDepth();
  //         for(int level=0;level<depth;level++)
  //         {
  //           std::vector<CBoundingVolumeNode3<CAABB3r,Real,CTraits> *> vec=
  //           pMeshObject->m_BVH.GetNodesLevel(level);
  // 
  //           std::ostringstream sName;
  //           std::string sModel(strFileName);
  //           sName<<".level"<<level;
  //           sModel.append(sName.str());
  //           WriteTreeLevel(vec,sModel.c_str());
  //         }
  //       }
      
    }
  }

  for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
  {
    C3DModel &pModel = *modelIter;
    int ivertsModel=0;
    for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
    {
      C3DMesh &pMesh=*meshIter;
      iVerts+=pMesh.m_iNumVerts;
      iPolys+=pMesh.m_iNumFaces;
      ivertsModel+=pMesh.m_iNumVerts;
    }
    vVerts.push_back(ivertsModel);
  }

  fprintf(myfile,"# vtk DataFile Version 2.0\n");
  fprintf(myfile,"Generated by InShape 2.x\n");
  fprintf(myfile,"ASCII\n");
  fprintf(myfile,"DATASET POLYDATA\n");
  fprintf(myfile,"POINTS %i double\n",iVerts);

  //write the actual vertex data
  for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
  {
    C3DModel &pModel = *modelIter;
    for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
    {
    C3DMesh &pMesh=*meshIter;
    for(int i=0;i<pMesh.m_pVertices.Size();i++)
    {
      fprintf(myfile,"%f %f %f \n",pMesh.m_pVertices[i].x,pMesh.m_pVertices[i].y,pMesh.m_pVertices[i].z);
    }//end for
    }//for
  }//end for

  int lengthPolyList=4*iPolys;
  fprintf(myfile,"POLYGONS %i %i \n",iPolys,lengthPolyList);
  vertsIter = vVerts.begin();
  for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
  {
    C3DModel &pModel = *modelIter;
    int ivertsModel = *vertsIter;
    for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
    {
      C3DMesh &pMesh=*meshIter;
      for(int i=0;i<pMesh.m_iNumFaces;i++)
      {
        fprintf(myfile,"3 %i %i %i \n",pMesh.m_pFaces[i][0]+ioffset, pMesh.m_pFaces[i][1]+ioffset, pMesh.m_pFaces[i][2]+ioffset);
      }//end for faces
      ioffset+=pMesh.m_iNumVerts;
    }//for submeshes
    vertsIter++;
  }//for models

  fprintf(myfile,"POINT_DATA %i \n",iVerts);
  fprintf(myfile,"SCALARS dummy double 1 \n");
  fprintf(myfile,"LOOKUP_TABLE default\n");
  int modelid=0;
  for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
  {
    C3DModel &pModel = *modelIter;
    for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
    {
    C3DMesh &pMesh=*meshIter;
      for(int i=0;i<pMesh.m_pVertices.Size();i++)
      {
        fprintf(myfile,"%f\n",(pMesh.m_pVertices[0]-pMesh.m_pVertices[i]).mag());
      }//end for
    }//for
    modelid++;
  }//end for
  fprintf(myfile,"CELL_DATA %i \n",iPolys);
  fprintf(myfile,"SCALARS CellID int 1\n");
  fprintf(myfile,"LOOKUP_TABLE default\n");
  int cellid=0;
  for(modelIter = pModels.begin(),rIter=pRigidBodies.begin();modelIter!=pModels.end();modelIter++,rIter++)
  {
    RigidBody &body = *(*rIter);
    C3DModel &pModel = *modelIter;
    for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
    {
    C3DMesh &pMesh=*meshIter;
      for(int i=0;i<pMesh.m_iNumFaces;i++)
      {
        fprintf(myfile,"%i \n",cellid);
      }//end for faces
    }//for submeshes
    cellid++;
  }//for models

  fprintf(myfile,"SCALARS ContactGroup int 1\n");
  fprintf(myfile,"LOOKUP_TABLE default\n");
  for(modelIter = pModels.begin(),rIter=pRigidBodies.begin();modelIter!=pModels.end();modelIter++,rIter++)
  {
    RigidBody &body = *(*rIter);
    C3DModel &pModel = *modelIter;
    for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
    {
    C3DMesh &pMesh=*meshIter;
      for(int i=0;i<pMesh.m_iNumFaces;i++)
      {
        fprintf(myfile,"%i \n",body.group_);
      }//end for faces
    }//for submeshes
    cellid++;
  }//for models

  fprintf(myfile,"SCALARS StackHeight int 1\n");
  fprintf(myfile,"LOOKUP_TABLE default\n");
  for(modelIter = pModels.begin(),rIter=pRigidBodies.begin();modelIter!=pModels.end();modelIter++,rIter++)
  {
    RigidBody &body = *(*rIter);
    C3DModel &pModel = *modelIter;
    for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
    {
    C3DMesh &pMesh=*meshIter;
      for(int i=0;i<pMesh.m_iNumFaces;i++)
      {
        fprintf(myfile,"%i \n",body.height_);
      }//end for faces
    }//for submeshes
    cellid++;
  }//for models 

  fclose (myfile);

}

void CVtkWriter::WriteModels(std::vector<C3DModel> &pModels,const char *strFileName)
{
	using namespace std;
	
	FILE * myfile = fopen(strFileName,"w");

	if (myfile == NULL) {
		cout<<"Error opening file: "<<strFileName<<endl;
		exit(0);
	}

	//total number of vertices
	int iVerts=0;
	//total number of polygons
	int iPolys=0;
	//iterators for models and submeshes
	vector<C3DMesh>::iterator meshIter;
	vector<C3DModel>::iterator modelIter;
	vector<int> vVerts;
	vector<int>::iterator vertsIter;
	int ioffset=0;

  //write the vertices of all models
	for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
	{
		C3DModel &pModel = *modelIter;
		int ivertsModel=0;
		for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
		{
			C3DMesh &pMesh=*meshIter;
			iVerts+=pMesh.m_iNumVerts;
			iPolys+=pMesh.m_iNumFaces;
			ivertsModel+=pMesh.m_iNumVerts;
		}
		vVerts.push_back(ivertsModel);
	}

	fprintf(myfile,"# vtk DataFile Version 2.0\n");
	fprintf(myfile,"Generated by InShape 2.x\n");
	fprintf(myfile,"ASCII\n");
	fprintf(myfile,"DATASET POLYDATA\n");
	fprintf(myfile,"POINTS %i double\n",iVerts);
	
	//write the actual vertex data
	for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
	{
		C3DModel &pModel = *modelIter;
		for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
		{
		  C3DMesh &pMesh=*meshIter;
		  for(int i=0;i<pMesh.m_pVertices.Size();i++)
		  {
			  fprintf(myfile,"%f %f %f \n",pMesh.m_pVertices[i].x,pMesh.m_pVertices[i].y,pMesh.m_pVertices[i].z);
		  }//end for
		}//for
	}//end for

	int lengthPolyList=4*iPolys;
	fprintf(myfile,"POLYGONS %i %i \n",iPolys,lengthPolyList);
	vertsIter = vVerts.begin();
	for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
	{
		C3DModel &pModel = *modelIter;
		int ivertsModel = *vertsIter;
    int subMeshOffset = 0;
		for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
		{
		  C3DMesh &pMesh=*meshIter;
			for(int i=0;i<pMesh.m_iNumFaces;i++)
			{
				fprintf(myfile,"3 %i %i %i \n",pMesh.m_pFaces[i][0]+ioffset+subMeshOffset, pMesh.m_pFaces[i][1]+ioffset+subMeshOffset, pMesh.m_pFaces[i][2]+ioffset+subMeshOffset);
			}//end for faces
      subMeshOffset+=pMesh.GetNumVerts();
		}//for submeshes
		ioffset+=ivertsModel;
		vertsIter++;
	}//for models
	
	fprintf(myfile,"CELL_DATA %i \n",iPolys);
	fprintf(myfile,"SCALARS CellID int 1\n");
	fprintf(myfile,"LOOKUP_TABLE default\n");
	
	int iModel=0;
	for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
	{
		C3DModel &pModel = *modelIter;
		for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
		{
		C3DMesh &pMesh=*meshIter;
		//cout<<"Collision state: "<<body.m_iCollisionState<<endl;
			for(int i=0;i<pMesh.m_iNumFaces;i++)
			{
				fprintf(myfile,"%i \n",iModel);
			}//end for faces
		}//for submeshes
		iModel++;
	}//for models	
	
	fclose (myfile);
	
}//end function


void CVtkWriter::WriteTreeLevel(std::vector<CBoundingVolumeNode3<CAABB3r,Real,CTraits> *> &vec, const char *strFileName)
{
	
  using namespace std;
  ofstream myfile(strFileName);

  //check
  if(!myfile.is_open())
  {
	cout<<"Error opening file: "<<"output.vtk"<<endl;
	exit(0);
  }//end if
  
  int NVE=8;
	int iPoints= (int)vec.size()*NVE;
  int iCells = (int)vec.size();
  myfile<<"# vtk DataFile Version 2.0"<<endl;
  myfile<<"Generated by InShape 2.x"<<endl;
  myfile<<"ASCII"<<endl;
  myfile<<"DATASET UNSTRUCTURED_GRID"<<endl;
  myfile<<"POINTS "<<iPoints<<" double"<<endl;
  myfile.precision(7);
	
	vector<CBoundingVolumeNode3<CAABB3r,Real,CTraits> *>::iterator vIter;
	
  for(vIter=vec.begin();vIter!=vec.end();vIter++)
  {
		CBoundingVolumeNode3<CAABB3r,Real,CTraits> *pNode=*vIter;
		CAABB3r &rBox=pNode->m_BV;
		for(int j=0;j<8;j++)
		{
			myfile<<rBox.GetVertex(j).x<<" "<<rBox.GetVertex(j).y<<" "<<rBox.GetVertex(j).z<<endl;
		}
  }//end for
  
  myfile.precision();
  myfile<<"CELLS "<<iCells<<" "<<iCells*9<<endl;
  for(int i=0;i<(int)vec.size();i++)
  {
	myfile <<8<<" ";
	for(int j=0;j<8;j++)
	  myfile<<(i*8)+j<<" ";
	myfile<<endl;
  }//end for
  
  myfile<<"CELL_TYPES "<<iCells<<endl;
  for(int i=0;i<iCells;i++)
  {
	myfile<<12<<endl;
  }//end for
  
  myfile<<"CELL_DATA "<<iCells<<endl;
  myfile<<"SCALARS "<<"Collision int 1"<<endl;
  myfile<<"LOOKUP_TABLE default"<<endl;
  for(int i=0;i<iCells;i++)
  {
	myfile<<vec[i]->m_Traits.iCollision<<endl;
  }//end for  

  //close the file
  myfile.close();
}

void CVtkWriter::WritePoints(std::vector<VECTOR3> &points,const char *strFileName)
{
  using namespace std;
  FILE * myfile = fopen(strFileName,"w");

  if (myfile == NULL) {
    cout<<"Error opening file: "<<strFileName<<endl;
    exit(0);
  }
  
  int i,j;
  
  fprintf(myfile,"# vtk DataFile Version 2.0\n");
  fprintf(myfile,"Generated by InShape 2.x\n");
  fprintf(myfile,"ASCII\n");
  fprintf(myfile,"DATASET UNSTRUCTURED_GRID\n");

  //total number of vertices
  int iVerts=points.size();
  //total number of polygons
  int iPolys=0;
  //iterators for models and submeshes
  vector<VECTOR3>::iterator vIter;

  fprintf(myfile,"POINTS %i double\n",iVerts);  

  for(vIter=points.begin();vIter!=points.end();vIter++)
  {
    VECTOR3 &vec = *vIter;
    fprintf(myfile,"%f %f %f \n",vec.x,vec.y,vec.z);      
  }

  fclose( myfile );

}

void CVtkWriter::WriteTriangles(std::vector<CTriangle3<Real> > &pTriangles,const char *strFileName)
{
	using namespace std;
	
	FILE * myfile = fopen(strFileName,"w");

	if (myfile == NULL) {
		cout<<"Error opening file: "<<strFileName<<endl;
		exit(0);
	}

	//total number of vertices
	int iVerts=pTriangles.size()*3;
	//total number of polygons
	int iPolys=pTriangles.size();

	fprintf(myfile,"# vtk DataFile Version 2.0\n");
	fprintf(myfile,"Generated by InShape 2.x\n");
	fprintf(myfile,"ASCII\n");
	fprintf(myfile,"DATASET POLYDATA\n");
	fprintf(myfile,"POINTS %i double\n",iVerts);
	
	//write the actual vertex data
	for(int k=0;k<iPolys;k++)
	{
    VECTOR3 tri[3];
    tri[0]=pTriangles[k].m_vV0;
    tri[1]=pTriangles[k].m_vV1;
    tri[2]=pTriangles[k].m_vV2;
		for(int i=0;i<3;i++)
		{
      fprintf(myfile,"%f %f %f \n",tri[i].x,tri[i].y,tri[i].z);
		}//end for
	}//end for

	int lengthPolyList=4*iPolys;
	fprintf(myfile,"POLYGONS %i %i \n",iPolys,lengthPolyList);
  for(int i=0;i<pTriangles.size();i++)
	{
		fprintf(myfile,"3 %i %i %i \n",i*3,i*3+1,i*3+2);
	}//end for faces
		
	fclose (myfile);
	
}//end function


void CVtkWriter::WriteModels(std::vector<C3DModel> &pModels,std::list<CollisionInfo> &vCollInfo,
														 std::vector<VECTOR3> &vVel,std::list<CResponse> &Responses,const char *strFileName)
{
	using namespace std;
	ofstream myfile(strFileName);
	//total number of vertices
	int iVerts=0;
	//total number of polygons
	int iPolys=0;
	//iterators for models and submeshes
	vector<C3DMesh>::iterator meshIter;
	vector<C3DModel>::iterator modelIter;
	vector<int> vVerts;
	vector<int> vOffset;
	vector<int>::iterator vertsIter;
	int ioffset=0;

	//check
	if(!myfile.is_open())
	{
	cout<<"Error opening file: "<<strFileName<<endl;
	exit(0);
	}//end if


	for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
	{
		C3DModel &pModel = *modelIter;
		int ivertsModel=0;
		for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
		{
			C3DMesh &pMesh=*meshIter;
			iVerts+=pMesh.m_iNumVerts;
			iPolys+=pMesh.m_iNumFaces;
			ivertsModel+=pMesh.m_iNumVerts;
		}
		//offset to the models vertices
		vOffset.push_back(ioffset);
		ioffset+=ivertsModel;
		//total vertices of the model
		vVerts.push_back(ivertsModel);
	}

	myfile<<"# vtk DataFile Version 2.0"<<endl;
	myfile<<"Generated by InShape 2.x"<<endl;
	myfile<<"ASCII"<<endl;
	myfile<<"DATASET POLYDATA"<<endl;
	myfile<<"POINTS "<<iVerts<<" double"<<endl;
	myfile.precision(7);
	//write the actual vertex data
	for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
	{
		C3DModel &pModel = *modelIter;
		for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
		{
		C3DMesh &pMesh=*meshIter;
		for(int i=0;i<pMesh.m_pVertices.Size();i++)
		{
			myfile<<pMesh.m_pVertices[i].x<<" "<<pMesh.m_pVertices[i].y<<" "<<pMesh.m_pVertices[i].z<<endl;
		}//end for
		}//for
	}//end for

	int lengthPolyList=4*iPolys;
	myfile<<"POLYGONS "<<iPolys<<" "<<lengthPolyList<<endl;
	vertsIter = vVerts.begin();
	ioffset=0;
	for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
	{
		C3DModel &pModel = *modelIter;
		int ivertsModel = *vertsIter;
		for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
		{
		C3DMesh &pMesh=*meshIter;
			for(int i=0;i<pMesh.m_iNumFaces;i++)
			{
				myfile<<3<<" "<<pMesh.m_pFaces[i][0]+ioffset<<" "
					<<pMesh.m_pFaces[i][1]+ioffset<<" "<<pMesh.m_pFaces[i][2]+ioffset<<endl;
			}//end for faces
		}//for submeshes
		ioffset+=ivertsModel;
		vertsIter++;
	}//for models
	myfile<<"POINT_DATA "<<iVerts<<endl;
	//myfile<<"SCALARS distance double"<<endl;
	//myfile<<"LOOKUP_TABLE default"<<endl;
	//for(int i=0;i<vVerts.size();i++)
	//{
	//	for(int j=0;j<vVerts[i];j++)
	//		myfile<<vCollInfo.front().m_dDistance<<endl;
	//}

	myfile<<"VECTORS velocity double"<<endl;
	//myfile<<"LOOKUP_TABLE default"<<endl;
	for(int i=0;i<vVerts.size();i++)
	{
		for(int j=0;j<vVerts[i];j++)
			myfile<<vVel[i].x<<" "<<vVel[i].y<<" "<<vVel[i].z<<endl;
	}

// 	myfile<<"VECTORS FCollParticle double"<<endl;
// 	list<CResponse>::iterator lIter;
// 	for(lIter=Responses.begin();lIter!=Responses.end();lIter++)
// 	{
// 		CResponse res= *lIter;
// 		for(int j=0;j<vVerts[0];j++)
// 		{
// 			myfile<<res.m_vFW1.x<<" "<<res.m_vFW1.y<<" "<<res.m_vFW1.z<<endl;
// 		}
// 		for(int j=0;j<vVerts[1];j++)
// 		{
// 			myfile<<res.m_vFW2.x<<" "<<res.m_vFW2.y<<" "<<res.m_vFW2.z<<endl;
// 		}
// 	}

}//end function

void CVtkWriter::WritePVTU(int iSubNodes, int iTimestep)
{
  using namespace std;
  int iRangeMin,iRangeMax;
	double dRangeMin,dRangeMax;
	std::ostringstream sNameMain;
	sNameMain<<"_gmv/main."<<std::setfill('0')<<std::setw(4)<<iTimestep<<".pvtu";
  string strFileName(sNameMain.str());

	vector<string> vNames;
	string strEnding(".vtu");
	for(int i=1;i<=iSubNodes;i++)
	{

		//build the string for the current node
		std::ostringstream sName;
		sName<<"node_"<<std::setfill('0')<<std::setw(2)<<i<<"."<<std::setfill('0')<<std::setw(4)<<iTimestep;
		
		string strName("res_");
		strName.append(sName.str());
		strName.append(strEnding);
		vNames.push_back(strName);
	}
	
	//open file for writing
	FILE * myfile = fopen(strFileName.c_str(),"w");

  //Write the vtk header
  fprintf(myfile,"<VTKFile type=\"PUnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">\n");
  fprintf(myfile,"  <PUnstructuredGrid GhostLevel=\"0\">\n");

  fprintf(myfile,"    <PPointData Scalars=\"FBM\">\n");
  fprintf(myfile,"      <PDataArray type=\"Float32\" Name=\"FBM\"/>\n");
//  myfile<<"      <PDataArray type=\"double32\" Name=\"Pressure\"/>"<<endl;
  fprintf(myfile,"      <PDataArray type=\"Float32\" Name=\"velocity\" NumberOfComponents=\"3\"/>\n");
  fprintf(myfile,"    </PPointData>\n");
  fprintf(myfile,"    <PPoints>\n");
  fprintf(myfile,"      <PDataArray type=\"Float32\" Name=\"Points\" NumberOfComponents=\"3\"/>\n");
  fprintf(myfile,"    </PPoints>\n");
	for(int i=0;i<iSubNodes;i++)
	{
    fprintf(myfile,"      <Piece Source=\"%s\"/>\n",vNames[i].c_str());
	}

  //add the finish tags
  fprintf(myfile,"  </PUnstructuredGrid>\n");
  fprintf(myfile,"</VTKFile>\n");
	
	//close the stream
	fclose( myfile );
  
}

void CVtkWriter::WritePUXML(int iNEL,int iNVT,int iKVERT[][8],double dcorvg[][3],double vu[],double vv[],double vw[],double vp[],double dist[],int inode, int iTimestep)
{

  using namespace std;
  int iRangeMin,iRangeMax;
	double dRangeMin,dRangeMax;

	std::ostringstream sName;
	sName<<"node_"<<std::setfill('0')<<std::setw(2)<<inode<<"."<<std::setfill('0')<<std::setw(4)<<iTimestep;
	
	string strEnding(".vtu");
	string strFileName("_gmv/res_");
	strFileName.append(sName.str());
	strFileName.append(strEnding);
	
	//open file for writing
	FILE * myfile = fopen(strFileName.c_str(),"w");

  //check
	fprintf(myfile,"<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">\n");

  //Write the vtk header
  fprintf(myfile,"  <UnstructuredGrid>\n");
  
  //Next item is the number of points and cells
  fprintf(myfile,"    <Piece NumberOfPoints=\"%i\" NumberOfCells=\"%i\">\n",iNVT,iNEL);

  //write the pointdata distance scalar
  fprintf(myfile,"      <PointData Scalars=\"FBM\">\n");

  fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"FBM\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"1.0\">\n");
  for(int i=0;i<iNVT;i++)
  {
		fprintf(myfile,"          %f\n",dist[i]);
  }//end for

  fprintf(myfile,"        </DataArray>\n");

//   //write the pointdata distance scalar
//   fprintf(myfile,"        <DataArray type=\"double32\" Name=\"Pressure\" format=\"ascii\">\n");
//   for(int i=0;i<iNVT;i++)
//   {
//   fprintf(myfile,"          %f \n",vp[i]);
//   }//end for
//   fprintf(myfile,"        </DataArray>\n");

	
	
	//before we write the velocity, we have to calculate the minimum and maximum
	//before we write the velocity, we have to calculate the minimum and maximum
	if(vu[0]<=vv[0])
	{
		if(vu[0]<=vw[0])
		{
			dRangeMin=vu[0];
		}
		else
		{
			dRangeMin=vw[0];
		}
	}
	else
	{
		if(vv[0]<=vw[0])
		{
			dRangeMin=vv[0];
		}
		else
		{
			dRangeMin=vw[0];
		}
	}
	
	if(vu[0]>=vv[0])
	{
		if(vu[0]>=vw[0])
		{
			dRangeMax=vu[0];
		}
		else
		{
			dRangeMax=vw[0];
		}
	}
	else
	{
		if(vv[0]>=vw[0])
		{
			dRangeMax=vv[0];
		}
		else
		{
			dRangeMax=vw[0];
		}		
	}	
	
	for(int i=1;i<iNVT;i++)
	{
		if(vu[i]<dRangeMin)
			dRangeMin=vu[i];
		if(vv[i]<dRangeMin)
			dRangeMin=vv[i];
		if(vw[i]<dRangeMin)
			dRangeMin=vw[i];

		if(vu[i]>dRangeMax)
			dRangeMax=vu[i];
		if(vv[i]>dRangeMax)
			dRangeMax=vv[i];
		if(vw[i]>dRangeMax)
			dRangeMax=vw[i];
		
	}
	
  //write the pointdata velocity array
//  fprintf(myfile,"      <PointData Vectors=\"velocity\">\n");
  fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"velocity\" NumberOfComponents=\"3\" format=\"ascii\" RangeMin=\"%f\" RangeMax=\"%f\">\n", dRangeMin,dRangeMax);
  for(int i=0;i<iNVT;i++)
  {
  fprintf(myfile,"          %f %f %f\n",vu[i],vv[i],vw[i]);
  }//end for

  fprintf(myfile,"        </DataArray>\n");
  fprintf(myfile,"      </PointData>\n");
	
  //write the points data array to the file
  fprintf(myfile,"      <Points>\n");
  fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"Points\" NumberOfComponents=\"3\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"1.0\">\n");
  for(int i=0;i<iNVT;i++)
  {
  fprintf(myfile,"          %f %f %f\n",dcorvg[i][0],dcorvg[i][1],dcorvg[i][2]);
  }//end for

  fprintf(myfile,"        </DataArray>\n");
  fprintf(myfile,"      </Points>\n");
  
  //Next item is the cell data array
  fprintf(myfile,"      <Cells>\n");
  fprintf(myfile,"        <DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"%i\">\n",iNEL-1);
  fprintf(myfile,"          ");
  for(int i=0;i<iNEL;i++)
  {
  fprintf(myfile,"          %i %i %i %i %i %i %i %i\n",iKVERT[i][0]-1,iKVERT[i][1]-1,iKVERT[i][2]-1,iKVERT[i][3]-1,iKVERT[i][4]-1,iKVERT[i][5]-1,iKVERT[i][6]-1,iKVERT[i][7]-1);
  }

	fprintf(myfile,"</DataArray>\n");

  //the offset seems to be mandatory
	fprintf(myfile,"        <DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\" RangeMin=\"8\" RangeMax=\"%i\">\n",iNEL*8);
	fprintf(myfile,"          ");
  for(int i=1;i<=iNEL;i++)
  {
	fprintf(myfile,"%i ",i*8);
    if(i%6==0)
    {
			fprintf(myfile,"\n");
			fprintf(myfile,"          ");
    }
  }

  if(iNEL%6!=0)fprintf(myfile,"\n");
	fprintf(myfile,"        </DataArray>\n");
  
  //add a data array with the types of the cells
	fprintf(myfile,"        <DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\" RangeMin=\"12\" RangeMax=\"12\">\n");
	fprintf(myfile,"          ");
  for(int i=1;i<=iNEL;i++)
  {
		fprintf(myfile,"12 ");
    if(i%6==0)
    {
			fprintf(myfile,"\n");
			fprintf(myfile,"          ");
    }
  }

  if(iNEL%6!=0)	fprintf(myfile,"\n");
	fprintf(myfile,"        </DataArray>\n");

  //finish the cells and the piece
	fprintf(myfile,"      </Cells>\n");
	fprintf(myfile,"    </Piece>\n");
  
  //add the finish tags
	fprintf(myfile,"  </UnstructuredGrid>\n");
	fprintf(myfile,"</VTKFile>\n");
	
	fclose( myfile );
	
}

void CVtkWriter::WriteGrid2Tri(CUnstrGrid &Grid, const char *strFileName)
{
  using namespace std;
  
  //open file for writing
  FILE * myfile = fopen(strFileName,"w");
  
  fprintf(myfile,"Coarse mesh exported by KaBooM \n");
  fprintf(myfile,"Version 0.1a \n");
  
  fprintf(myfile,"    %i %i 0 8 12 6     NEL,NVT,NBCT,NVE,NEE,NAE\n",Grid.m_iNEL,Grid.m_iNVT); 
  
  fprintf(myfile,"DCORVG\n");  
  //write the points data array to the file
  for(int i=0;i<Grid.m_iNVT;i++)
  {
    fprintf(myfile,"%f %f %f\n",Grid.m_pVertexCoords[i].x,Grid.m_pVertexCoords[i].y,Grid.m_pVertexCoords[i].z);
  }//end for
  
  fprintf(myfile,"KVERT\n");
  for(int i=0;i<Grid.m_iNEL;i++)
  {
    fprintf(myfile,"%i %i %i %i %i %i %i %i\n",Grid.m_pHexas[i].m_iVertInd[0]+1,Grid.m_pHexas[i].m_iVertInd[1]+1,Grid.m_pHexas[i].m_iVertInd[2]+1,Grid.m_pHexas[i].m_iVertInd[3]+1,
                                               Grid.m_pHexas[i].m_iVertInd[4]+1,Grid.m_pHexas[i].m_iVertInd[5]+1,Grid.m_pHexas[i].m_iVertInd[6]+1,Grid.m_pHexas[i].m_iVertInd[7]+1);
  }   

  fprintf(myfile,"KNPR\n");
  for(int i=0;i<Grid.m_iNVT;i++)
  {
    fprintf(myfile,"%i\n",Grid.m_piVertAtBdr[i]);
  }

  fclose( myfile );  

}

void CVtkWriter::WriteTriFile(int NEL, int NVT, int iKVERT[][8], double dcorvg[][3],int id)
{
  using namespace std;
  std::ostringstream sName;
  sName<<"grid_"<<std::setfill('0')<<std::setw(2)<<id;
  
  string strEnding(".tri");
  string strFileName("_gmv/");
  strFileName.append(sName.str());
  strFileName.append(strEnding);

  //open file for writing
  FILE * myfile = fopen(strFileName.c_str(),"w");
  
  fprintf(myfile,"Coarse mesh exported by KaBooM \n");
  fprintf(myfile,"Version 0.1a \n");
  
  fprintf(myfile,"    %i %i 0 8 12 6     NEL,NVT,NBCT,NVE,NEE,NAE\n",NEL,NVT); 
  
  fprintf(myfile,"DCORVG\n");  
  //write the points data array to the file
  for(int i=0;i<NVT;i++)
  {
  fprintf(myfile,"%f %f %f\n",dcorvg[i][0],dcorvg[i][1],dcorvg[i][2]);
  }//end for
  
  fprintf(myfile,"KVERT\n");
  for(int i=0;i<NEL;i++)
  {
    fprintf(myfile,"%i %i %i %i %i %i %i %i\n",iKVERT[i][0],iKVERT[i][1],iKVERT[i][2],iKVERT[i][3],iKVERT[i][4],iKVERT[i][5],iKVERT[i][6],iKVERT[i][7]);
  }

  fprintf(myfile,"KNPR\n");
  for(int i=0;i<NVT;i++)
  {
    fprintf(myfile,"0\n");
  }

  fclose( myfile );  
}

void CVtkWriter::WriteVTK22(int *NEL,int *NVT,int iKVERT[][8],double dcorvg[][3],double dmon1[],double dmon2[],double df[],double du[],double dgradx[],double dgrady[],double dgradz[],double *dt, double *ddt,int ivl, int imst, int itst,int ismst)
{

  using namespace std;
  int iRangeMin,iRangeMax;
  double dRangeMin,dRangeMax;
  int iNEL = *NEL;
  int iNVT = *NVT;  
  std::ostringstream sName;
  int inode = 0;
  int iTimestep = 0;
  sName<<"SOL."<<std::setfill('0')<<std::setw(2)<<ivl<<"."<<std::setfill('0')<<std::setw(3)<<imst<<"."<<std::setfill('0')<<std::setw(3)<<itst<<"."<<std::setfill('0')<<std::setw(4)<<ismst;
  
  string strEnding(".vtu");
  string strFileName("_gmv/");
  strFileName.append(sName.str());
  strFileName.append(strEnding);
  
  //open file for writing
  FILE * myfile = fopen(strFileName.c_str(),"w");

  //check
  fprintf(myfile,"<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">\n");

  //Write the vtk header
  fprintf(myfile,"  <UnstructuredGrid>\n");
  
  //Next item is the number of points and cells
  fprintf(myfile,"    <Piece NumberOfPoints=\"%i\" NumberOfCells=\"%i\">\n",iNVT,iNEL);

  //write the pointdata distance scalar
  fprintf(myfile,"      <PointData Scalars=\"MonitorOld\">\n");

  fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"MonitorOld\" format=\"ascii\">\n");
  for(int i=0;i<iNVT;i++)
  {
    fprintf(myfile,"          %f\n",dmon1[i]);
  }//end for

  fprintf(myfile,"        </DataArray>\n");

  fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"MonitorNew\" format=\"ascii\">\n");
  for(int i=0;i<iNVT;i++)
  {
    fprintf(myfile,"          %f\n",dmon2[i]);
  }//end for

  fprintf(myfile,"        </DataArray>\n");

  fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"DF\" format=\"ascii\">\n");
  for(int i=0;i<iNVT;i++)
  {
    fprintf(myfile,"          %f\n",df[i]);
  }//end for

  fprintf(myfile,"        </DataArray>\n");
  
  fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"DU\" format=\"ascii\">\n");
  for(int i=0;i<iNVT;i++)
  {
    fprintf(myfile,"          %f\n",du[i]);
  }//end for

  fprintf(myfile,"        </DataArray>\n");
  
  //write the pointdata velocity array
  fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"gradient\" NumberOfComponents=\"3\" format=\"ascii\">\n");
  for(int i=0;i<iNVT;i++)
  {
  fprintf(myfile,"          %f %f %f\n",dgradx[i],dgrady[i],dgradz[i]);
  }//end for

  fprintf(myfile,"        </DataArray>\n");
  fprintf(myfile,"      </PointData>\n");
	
  //write the points data array to the file
  fprintf(myfile,"      <Points>\n");
  fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"Points\" NumberOfComponents=\"3\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"1.0\">\n");
  for(int i=0;i<iNVT;i++)
  {
  fprintf(myfile,"          %f %f %f\n",dcorvg[i][0],dcorvg[i][1],dcorvg[i][2]);
  }//end for

  fprintf(myfile,"        </DataArray>\n");
  fprintf(myfile,"      </Points>\n");
  
  //Next item is the cell data array
  fprintf(myfile,"      <Cells>\n");
  fprintf(myfile,"        <DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"%i\">\n",iNEL-1);
  fprintf(myfile,"          ");
  for(int i=0;i<iNEL;i++)
  {
  fprintf(myfile,"          %i %i %i %i %i %i %i %i\n",iKVERT[i][0]-1,iKVERT[i][1]-1,iKVERT[i][2]-1,iKVERT[i][3]-1,iKVERT[i][4]-1,iKVERT[i][5]-1,iKVERT[i][6]-1,iKVERT[i][7]-1);
  }

	fprintf(myfile,"</DataArray>\n");

  //the offset seems to be mandatory
	fprintf(myfile,"        <DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\" RangeMin=\"8\" RangeMax=\"%i\">\n",iNEL*8);
	fprintf(myfile,"          ");
  for(int i=1;i<=iNEL;i++)
  {
	fprintf(myfile,"%i ",i*8);
    if(i%6==0)
    {
			fprintf(myfile,"\n");
			fprintf(myfile,"          ");
    }
  }

  if(iNEL%6!=0)fprintf(myfile,"\n");
	fprintf(myfile,"        </DataArray>\n");
  
  //add a data array with the types of the cells
	fprintf(myfile,"        <DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\" RangeMin=\"12\" RangeMax=\"12\">\n");
	fprintf(myfile,"          ");
  for(int i=1;i<=iNEL;i++)
  {
		fprintf(myfile,"12 ");
    if(i%6==0)
    {
			fprintf(myfile,"\n");
			fprintf(myfile,"          ");
    }
  }

  if(iNEL%6!=0)	fprintf(myfile,"\n");
	fprintf(myfile,"        </DataArray>\n");

  //finish the cells and the piece
	fprintf(myfile,"      </Cells>\n");
	fprintf(myfile,"    </Piece>\n");
  
  //add the finish tags
	fprintf(myfile,"  </UnstructuredGrid>\n");
	fprintf(myfile,"</VTKFile>\n");
	
	fclose( myfile );

  WriteTriFile(iNEL,iNVT,iKVERT,dcorvg,imst);
  
}

void CVtkWriter::WriteVTK23(int *NEL,int *NVT, int iKVERT[][8],double dcorvg[][3],
double dmon[],double dsize[],double dratio[],double *DT,double *DDT,int ivl,int imst,int itst,int ismst)
{

  using namespace std;
  int iRangeMin,iRangeMax;
  double dRangeMin,dRangeMax;
  int iNEL = *NEL;
  int iNVT = *NVT;  
  std::ostringstream sName;
  int inode = 0;
  int iTimestep = 0;
  sName<<"MACRO."<<std::setfill('0')<<std::setw(2)<<ivl<<"."<<std::setfill('0')<<std::setw(3)<<imst<<"."<<std::setfill('0')<<std::setw(3)<<itst<<"."<<std::setfill('0')<<std::setw(4)<<ismst;
  
  string strEnding(".vtu");
  string strFileName("_gmv/");
  strFileName.append(sName.str());
  strFileName.append(strEnding);
  
  //open file for writing
  FILE * myfile = fopen(strFileName.c_str(),"w");

  //check
  fprintf(myfile,"<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">\n");

  //Write the vtk header
  fprintf(myfile,"  <UnstructuredGrid>\n");
  
  //Next item is the number of points and cells
  fprintf(myfile,"    <Piece NumberOfPoints=\"%i\" NumberOfCells=\"%i\">\n",iNVT,iNEL);

  //write the pointdata distance scalar
  fprintf(myfile,"      <PointData Scalars=\"MonitorOld\">\n");

  fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"SmoothedMonitor\" format=\"ascii\">\n");
  for(int i=0;i<iNVT;i++)
  {
    fprintf(myfile,"          %f\n",dmon[i]);
  }//end for

  fprintf(myfile,"        </DataArray>\n");  
  
  fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"Size\" format=\"ascii\">\n");
  for(int i=0;i<iNVT;i++)
  {
    fprintf(myfile,"          %f\n",dsize[i]);
  }//end for

  fprintf(myfile,"        </DataArray>\n");
  
  fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"Ratio\" format=\"ascii\">\n");
  for(int i=0;i<iNVT;i++)
  {
    fprintf(myfile,"          %f\n",dratio[i]);
  }//end for

  fprintf(myfile,"        </DataArray>\n");
  
  fprintf(myfile,"      </PointData>\n");
	
  //write the points data array to the file
  fprintf(myfile,"      <Points>\n");
  fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"Points\" NumberOfComponents=\"3\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"1.0\">\n");
  for(int i=0;i<iNVT;i++)
  {
  fprintf(myfile,"          %f %f %f\n",dcorvg[i][0],dcorvg[i][1],dcorvg[i][2]);
  }//end for

  fprintf(myfile,"        </DataArray>\n");
  fprintf(myfile,"      </Points>\n");
  
  //Next item is the cell data array
  fprintf(myfile,"      <Cells>\n");
  fprintf(myfile,"        <DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"%i\">\n",iNEL-1);
  fprintf(myfile,"          ");
  for(int i=0;i<iNEL;i++)
  {
  fprintf(myfile,"          %i %i %i %i %i %i %i %i\n",iKVERT[i][0]-1,iKVERT[i][1]-1,iKVERT[i][2]-1,iKVERT[i][3]-1,iKVERT[i][4]-1,iKVERT[i][5]-1,iKVERT[i][6]-1,iKVERT[i][7]-1);
  }

	fprintf(myfile,"</DataArray>\n");

  //the offset seems to be mandatory
	fprintf(myfile,"        <DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\" RangeMin=\"8\" RangeMax=\"%i\">\n",iNEL*8);
	fprintf(myfile,"          ");
  for(int i=1;i<=iNEL;i++)
  {
	fprintf(myfile,"%i ",i*8);
    if(i%6==0)
    {
			fprintf(myfile,"\n");
			fprintf(myfile,"          ");
    }
  }

  if(iNEL%6!=0)fprintf(myfile,"\n");
	fprintf(myfile,"        </DataArray>\n");
  
  //add a data array with the types of the cells
	fprintf(myfile,"        <DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\" RangeMin=\"12\" RangeMax=\"12\">\n");
	fprintf(myfile,"          ");
  for(int i=1;i<=iNEL;i++)
  {
		fprintf(myfile,"12 ");
    if(i%6==0)
    {
			fprintf(myfile,"\n");
			fprintf(myfile,"          ");
    }
  }

  if(iNEL%6!=0)	fprintf(myfile,"\n");
	fprintf(myfile,"        </DataArray>\n");

  //finish the cells and the piece
	fprintf(myfile,"      </Cells>\n");
	fprintf(myfile,"    </Piece>\n");
  
  //add the finish tags
	fprintf(myfile,"  </UnstructuredGrid>\n");
	fprintf(myfile,"</VTKFile>\n");
	
	fclose( myfile );
	
}

void CVtkWriter::WriteUnstrXML(CUnstrGrid &Grid, const char * strFileName)
{
  using namespace std;
  int iRangeMin,iRangeMax;

	//open file for writing
	FILE * myfile = fopen(strFileName,"w");

  std::string indentation("");
  std::string space("  ");

	if (myfile == NULL) {
		cout<<"Error opening file: "<<strFileName<<endl;
		exit(0);
	}

	fprintf(myfile,"<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">\n");

  indentation.append(space);

  //Write the vtk header
  fprintf(myfile,"%s<UnstructuredGrid>\n",indentation.c_str());
  
  indentation.append(space);

  //Next item is the number of points and cells
  fprintf(myfile,"%s<Piece NumberOfPoints=\"%i\" NumberOfCells=\"%i\">\n",indentation.c_str(),Grid.m_iNVT,Grid.m_iNEL);

  indentation.append(space);

  //write the pointdata distance scalar
  fprintf(myfile,"%s<PointData Scalars=\"Distance\">\n",indentation.c_str());

  indentation.append(space);

  fprintf(myfile,"%s<DataArray type=\"Float32\" Name=\"Distance\" format=\"ascii\">\n",indentation.c_str());

  indentation.append(space);

	for(int i=0;i<Grid.m_iNVT;i++)
  {
		fprintf(myfile,"%s%f\n",indentation.c_str(),Grid.m_myTraits[i].distance);
  }//end for

  indentation.erase(indentation.size()-2,indentation.size());

  fprintf(myfile,"%s</DataArray>\n",indentation.c_str());

  //write the pointdata distance scalar
  fprintf(myfile,"%s<DataArray type=\"Float32\" Name=\"dist2\" format=\"ascii\">\n",indentation.c_str());

  indentation.append(space);

	for(int i=0;i<Grid.m_iNVT;i++)
  {
    fprintf(myfile,"%s%f\n",indentation.c_str(),Grid.m_myTraits[i].dist2);
  }//end for

  indentation.erase(indentation.size()-2,indentation.size());

  fprintf(myfile,"%s</DataArray>\n",indentation.c_str());


  //write the pointdata distance scalar
  fprintf(myfile,"%s<DataArray type=\"Float32\" Name=\"FBM\" format=\"ascii\">\n",indentation.c_str());

  indentation.append(space);

  for(int i=0;i<Grid.m_iNVT;i++)
  {
		fprintf(myfile,"%s%f \n",indentation.c_str(),double(Grid.m_myTraits[i].iTag));
  }//end for

  indentation.erase(indentation.size()-2,indentation.size());

  fprintf(myfile,"%s</DataArray>\n",indentation.c_str());

  indentation.erase(indentation.size()-2,indentation.size());

  fprintf(myfile,"%s</PointData>\n",indentation.c_str());

  indentation.erase(indentation.size()-2,indentation.size());

  //write the points data array to the file
  fprintf(myfile,"%s<Points>\n",indentation.c_str());

  indentation.append(space);

  fprintf(myfile,"%s<DataArray type=\"Float32\" Name=\"Points\" NumberOfComponents=\"3\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"1.0\">\n",indentation.c_str());

  indentation.append(space);

  for(int i=0;i<Grid.m_iNVT;i++)
  {
  fprintf(myfile,"%s%f %f %f\n",indentation.c_str(),Grid.m_pVertexCoords[i].x,Grid.m_pVertexCoords[i].y,Grid.m_pVertexCoords[i].z);
  }//end for

  indentation.erase(indentation.size()-2,indentation.size());

  fprintf(myfile,"%s</DataArray>\n",indentation.c_str());

  indentation.erase(indentation.size()-2,indentation.size());

  fprintf(myfile,"%s</Points>\n",indentation.c_str());
  
  indentation.append(space);

  //Next item is the cell data array
  fprintf(myfile,"%s<Cells>\n",indentation.c_str());

  indentation.append(space);

  fprintf(myfile,"%s<DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"%i\">\n",indentation.c_str(),Grid.m_iNEL-1);

  indentation.append(space);

  for(int i=0;i<Grid.m_iNEL;i++)
  {
  fprintf(myfile,"%s%i %i %i %i %i %i %i %i\n",indentation.c_str(),Grid.m_pHexas[i].m_iVertInd[0],
		Grid.m_pHexas[i].m_iVertInd[1],Grid.m_pHexas[i].m_iVertInd[2],
		Grid.m_pHexas[i].m_iVertInd[3],Grid.m_pHexas[i].m_iVertInd[4],
		Grid.m_pHexas[i].m_iVertInd[5],Grid.m_pHexas[i].m_iVertInd[6],Grid.m_pHexas[i].m_iVertInd[7]);
  }

  indentation.erase(indentation.size()-2,indentation.size());

  fprintf(myfile,"%s</DataArray>\n",indentation.c_str());

  //the offset seems to be mandatory
	fprintf(myfile,"%s<DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\" RangeMin=\"8\" RangeMax=\"%i\">\n",indentation.c_str(),Grid.m_iNEL*8);

  indentation.append(space);

	fprintf(myfile,"%s",indentation.c_str());

  for(int i=1;i<=Grid.m_iNEL;i++)
  {
	fprintf(myfile,"%i ",i*8);
    if(i%6==0)
    {
			fprintf(myfile,"\n");
			fprintf(myfile,"%s",indentation.c_str());
    }
  }

  if(Grid.m_iNEL%6!=0)fprintf(myfile,"\n");

  indentation.erase(indentation.size()-2,indentation.size());

	fprintf(myfile,"%s</DataArray>\n",indentation.c_str());
  
  //add a data array with the types of the cells
	fprintf(myfile,"%s<DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\" RangeMin=\"12\" RangeMax=\"12\">\n",indentation.c_str());

  indentation.append(space);

	fprintf(myfile,"%s",indentation.c_str());

  for(int i=1;i<=Grid.m_iNEL;i++)
  {
		fprintf(myfile,"12 ");
    if(i%6==0)
    {
			fprintf(myfile,"\n");
			fprintf(myfile,"%s",indentation.c_str());
    }
  }

  if(Grid.m_iNEL%6!=0)	fprintf(myfile,"\n");

  indentation.erase(indentation.size()-2,indentation.size());

	fprintf(myfile,"%s</DataArray>\n",indentation.c_str());

  indentation.erase(indentation.size()-2,indentation.size());

  //finish the cells and the piece
	fprintf(myfile,"%s</Cells>\n",indentation.c_str());

  indentation.erase(indentation.size()-2,indentation.size());

	fprintf(myfile,"%s</Piece>\n",indentation.c_str());

  indentation.erase(indentation.size()-2,indentation.size());
  
  //add the finish tags
	fprintf(myfile,"%s</UnstructuredGrid>\n",indentation.c_str());

  indentation.erase(indentation.size()-2,indentation.size());

	fprintf(myfile,"</VTKFile>\n");
	
	fclose( myfile );
}


void CVtkWriter::WriteBasf(std::vector<C3DModel> &pModels,const char *strFileName)
{
	using namespace std;
	ofstream myfile(strFileName);

	//total number of vertices
	int iVerts=0;
	//total number of polygons
	int iPolys=0;
	//iterators for models and submeshes
	vector<C3DMesh>::iterator meshIter;
	vector<C3DModel>::iterator modelIter;
	vector<int> vVerts;
	vector<int>::iterator vertsIter;
	int ioffset=0;

	//check
	if(!myfile.is_open())
	{
	cout<<"Error opening file: "<<strFileName<<endl;
	exit(0);
	}//end if

	for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
	{
		C3DModel &pModel = *modelIter;
		int ivertsModel=0;
		for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
		{
			C3DMesh &pMesh=*meshIter;
			iVerts+=pMesh.m_iNumVerts;
			iPolys+=pMesh.m_iNumFaces;
			ivertsModel+=pMesh.m_iNumVerts;
		}
		vVerts.push_back(ivertsModel);
	}

	myfile<<"# vtk DataFile Version 2.0"<<endl;
	myfile<<"Generated by InShape 2.x"<<endl;
	myfile<<"ASCII"<<endl;
	myfile<<"DATASET POLYDATA"<<endl;
	myfile<<"POINTS "<<iVerts<<" double"<<endl;
	myfile.precision(7);
	//write the actual vertex data
	for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
	{
		C3DModel &pModel = *modelIter;
		for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
		{
		C3DMesh &pMesh=*meshIter;
		for(int i=0;i<pMesh.m_pVertices.Size();i++)
		{
			myfile<<pMesh.m_pVertices[i].x<<" "<<pMesh.m_pVertices[i].y<<" "<<pMesh.m_pVertices[i].z<<endl;
		}//end for
		}//for
	}//end for

	int lengthPolyList=4*iPolys;
	myfile<<"POLYGONS "<<iPolys<<" "<<lengthPolyList<<endl;
	vertsIter = vVerts.begin();
	for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
	{
		C3DModel &pModel = *modelIter;
		int ivertsModel = *vertsIter;
		for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
		{
		C3DMesh &pMesh=*meshIter;
			for(int i=0;i<pMesh.m_iNumFaces;i++)
			{
				int a=pMesh.m_pFaces[i][0]+ioffset;
				int b=pMesh.m_pFaces[i][1]+ioffset;
				int c=pMesh.m_pFaces[i][2]+ioffset;
				myfile<<3<<" "<<pMesh.m_pFaces[i][0]+ioffset<<" "
					<<pMesh.m_pFaces[i][1]+ioffset<<" "<<pMesh.m_pFaces[i][2]+ioffset<<endl;
			}//end for faces
			ioffset+=1343;
		}//for submeshes
		vertsIter++;
	}//for models
	
  myfile<<"CELL_DATA "<<iPolys<<endl;
  myfile<<"SCALARS "<<"CellID int 1"<<endl;
  myfile<<"LOOKUP_TABLE default"<<endl;
	
	int iModel=0;
	for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
	{
		C3DModel &pModel = *modelIter;
		for(meshIter=pModel.m_vMeshes.begin();meshIter!=pModel.m_vMeshes.end();meshIter++)
		{
		C3DMesh &pMesh=*meshIter;
		//cout<<"Collision state: "<<body.m_iCollisionState<<endl;
			for(int i=0;i<pMesh.m_iNumFaces;i++)
			{
				myfile<<iModel<<endl;
			}//end for faces
		}//for submeshes
		iModel++;
	}//for models	
	
}//end function

void CVtkWriter::WriteContacts(std::vector<Contact> &vContacts, const char* strFileName)
{
  using namespace std;
	std::vector<Contact>::iterator cIter;

  int nContacts = vContacts.size();

  //open the file
  ofstream myfile0(strFileName);

	//check
	if(!myfile0.is_open())
	{
		cout<<"Error opening file: "<<strFileName<<endl;
	exit(0);
	}//end if

	myfile0<<"# vtk DataFile Version 2.0"<<endl;
	myfile0<<"Generated by InShape 2.x"<<endl;
	myfile0<<"ASCII"<<endl;
	myfile0<<"DATASET POLYDATA"<<endl;
  myfile0<<"POINTS "<<2*vContacts.size()<<" double"<<endl;
	myfile0.precision(7);

  for(cIter=vContacts.begin();cIter<vContacts.end();cIter++)
  {
    Contact contact = *cIter;
    contact.m_vNormal *= 0.05;
	  myfile0<<contact.m_vPosition0.x<<" "<<contact.m_vPosition0.y<<" "<<contact.m_vPosition0.z<<endl;
    myfile0<<contact.m_vPosition0.x+contact.m_vNormal.x<<
        " "<<contact.m_vPosition0.y+contact.m_vNormal.y<<
        " "<<contact.m_vPosition0.z+contact.m_vNormal.z<<endl;
  }//end for

  myfile0<<"LINES "<<nContacts<<" "<<nContacts*3<<endl;
  for(int i=0;i<2*nContacts;i+=2)
  {
    myfile0<<2<<" "<<i<<" "<<i+1<<endl;
  }

	myfile0.close();
}

void CVtkWriter::WriteParticleFile(std::vector<RigidBody*> &pRigidBodies,const char *strFileName)
{

  using namespace std;
  FILE * myfile = fopen(strFileName,"w");

  if (myfile == NULL) {
    cout<<"Error opening file: "<<strFileName<<endl;
    exit(0);
  }
  
  int i,j;
  
  fprintf(myfile,"# vtk DataFile Version 2.0\n");
  fprintf(myfile,"Generated by InShape 2.x\n");
  fprintf(myfile,"ASCII\n");
  fprintf(myfile,"DATASET UNSTRUCTURED_GRID\n");

  //total number of vertices
  int iVerts=0;
  //total number of polygons
  int iPolys=0;
  //iterators for models and submeshes
  vector<C3DMesh>::iterator meshIter;
  vector<C3DModel>::iterator modelIter;
  vector<RigidBody*>::iterator rIter;
  vector<C3DModel> pModels;
  vector<int> vVerts;
  vector<int>::iterator vertsIter;
  int ioffset=0;
  
  for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
  {
    RigidBody &body = *(*rIter);
    if(body.shapeId_ == RigidBody::SPHERE)
    {
      iVerts++;
    }
  }

  fprintf(myfile,"POINTS %i double\n",iVerts);  

  for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
  {
    RigidBody &body = *(*rIter);
    if(body.shapeId_ == RigidBody::SPHERE)
    {
      fprintf(myfile,"%f %f %f \n",body.com_.x,body.com_.y,body.com_.z);      
    }
  }

  fprintf(myfile,"POINT_DATA %i\n",iVerts);    
  fprintf(myfile,"SCALARS radius double 1\n");  
  fprintf(myfile,"LOOKUP_TABLE default\n");
  for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
  {
    RigidBody &body = *(*rIter);
    if(body.shapeId_ == RigidBody::SPHERE)
    {
      fprintf(myfile,"%f\n",2.0*body.shape_->GetAABB().m_Extends[0]);            
    }
  }

  fprintf(myfile,"SCALARS color double 1\n");  
  fprintf(myfile,"LOOKUP_TABLE default\n");
  for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
  {
    RigidBody &body = *(*rIter);
    if(body.shapeId_ == RigidBody::SPHERE)
    {
      fprintf(myfile,"%f\n",body.color_);            
    }
  }

  fprintf(myfile,"SCALARS particleID int 1\n");  
  fprintf(myfile,"LOOKUP_TABLE default\n");
  for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
  {
    RigidBody &body = *(*rIter);
    if(body.shapeId_ == RigidBody::SPHERE)
    {
      fprintf(myfile,"%d\n",body.iID_);            
    }
  }

  fclose( myfile );

}

void CVtkWriter::WriteUniformGrid(CUniformGrid< Real, CUGCell > &grid, const char* strFileName)
{
  using namespace std;
  ofstream myfile(strFileName);

  //check
  if(!myfile.is_open())
  {
	cout<<"Error opening file: "<<strFileName<<endl;
	exit(0);
  }//end if
    
  int i,j;
  myfile<<"# vtk DataFile Version 2.0\n";
  myfile<<"Generated by FullC0ntact\n";
  myfile<<"ASCII\n";
  myfile<<"DATASET STRUCTURED_POINTS\n";
  myfile<<"DIMENSIONS "<<int((2.0*grid.m_bxBox.m_Extends[0]+grid.m_dCellSize)/grid.m_dCellSize)+1<<
                    " "<<int((2.0*grid.m_bxBox.m_Extends[1]+grid.m_dCellSize)/grid.m_dCellSize)+1<<
                    " "<<int((2.0*grid.m_bxBox.m_Extends[2]+grid.m_dCellSize)/grid.m_dCellSize)+1<<"\n";
  VECTOR3 center = grid.m_bxBox.GetCenter() - VECTOR3(grid.m_bxBox.m_Extends[0],grid.m_bxBox.m_Extends[1],grid.m_bxBox.m_Extends[2]);
  myfile<<"ORIGIN "<<center.x<<" "<<center.y<<" "<<center.z<<"\n";
  myfile<<"SPACING "<<grid.m_dCellSize<<" "<<grid.m_dCellSize<<" "<<grid.m_dCellSize<<"\n";  

  myfile.close(); 
}

void CVtkWriter::WriteGJK(std::vector<VECTOR3> vertices, int iter, const char *strFileName)
{
  using namespace std;
  ofstream myfile(strFileName);

  //check
  if(!myfile.is_open())
  {
	cout<<"Error opening file: "<<strFileName<<endl;
	exit(0);
  }//end if
    
  int i,j;
  myfile<<"# vtk DataFile Version 2.0\n";
  myfile<<"Generated by FullC0ntact\n";
  myfile<<"ASCII\n";
  myfile<<"DATASET UNSTRUCTURED_GRID"<<endl;
  myfile<<"POINTS "<<vertices.size()<<" double"<<endl;
  myfile.precision(7);
  for(i=0;i<vertices.size();i++)
  {
	  myfile<<vertices[i].x<<" "<<vertices[i].y<<" "<<vertices[i].z<<endl;
  }//end for

  myfile<<"CELLS "<<1<<" "<<vertices.size()+1<<endl;
  myfile<<vertices.size()<<" ";
  for(i=0;i<vertices.size();i++)
  {
	  myfile<<i<<" ";
  }//end for

  myfile<<"\n";

  myfile<<"CELL_TYPES "<<1<<endl;

  int iverts = vertices.size();

  switch(iverts) {

  case 1:
    myfile<<1<<endl;
    break;
  case 2:
    myfile<<3<<endl;
    break;
  case 3:
    myfile<<5<<endl;
    break;
  case 4:
    myfile<<10<<endl;
    break;  
  }

  myfile.close();
}

void CVtkWriter::WriteMPR(std::vector<VECTOR3> vertices, int iter, const char *strFileName)
{
  using namespace std;
  ofstream myfile(strFileName);

  //check
  if(!myfile.is_open())
  {
  cout<<"Error opening file: "<<strFileName<<endl;
  exit(0);
  }//end if
    
  int i,j;
  myfile<<"# vtk DataFile Version 2.0\n";
  myfile<<"Generated by FullC0ntact\n";
  myfile<<"ASCII\n";
  myfile<<"DATASET UNSTRUCTURED_GRID"<<endl;
  myfile<<"POINTS "<<vertices.size()<<" double"<<endl;
  myfile.precision(7);
  for(i=0;i<vertices.size();i++)
  {
    myfile<<vertices[i].x<<" "<<vertices[i].y<<" "<<vertices[i].z<<endl;
  }//end for

  myfile<<"CELLS "<<3<<" "<< 5 + 3 + 3<<endl;
  myfile<<4<<" ";
  for(i=0;i<4;i++)
  {
    myfile<<i<<" ";
  }//end for

  myfile<<"\n";
  
  myfile<<2<<" 0 4\n";  

  myfile<<2<<" 5 6\n";  

  myfile<<"CELL_TYPES "<<3<<endl;

  myfile<<10<<endl;

  myfile<<3<<endl;

  myfile<<3<<endl;

  //myfile<<3<<endl;

  myfile<<"POINT_DATA "<<vertices.size()<<"\n";    
  myfile<<"SCALARS radius double "<<"\n";  

  myfile<<"LOOKUP_TABLE default\n";

  myfile<<"0.0\n";
  myfile<<"1.0\n";
  myfile<<"1.0\n";
  myfile<<"1.0\n";
  myfile<<"0.0\n";
  myfile<<"0.0\n";
  myfile<<"0.0\n";

  myfile.close();
}

}
