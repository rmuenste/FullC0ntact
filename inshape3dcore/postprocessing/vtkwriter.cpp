#include "vtkwriter.h"
#include <iostream>
#include <fstream>
#include <aabb3.h>
#include <obb3.h>
#include <triangulator.h>
#include <cylinder.h>
#include <sstream>
#include <iomanip>
#include <stdlib.h>
#include <meshobject.h>
#include <boundarycyl.h>
#include <tetrahedron.hpp>
#include <plane.h>

namespace i3d {

  CVtkWriter::CVtkWriter(void)
  {
  }

  CVtkWriter::~CVtkWriter(void)
  {
  }

  void CVtkWriter::WriteTetra(Tetrahedron<Real> &t, const char *strFileName)
  {

    using namespace std;
    FILE * myfile = fopen(strFileName,"w");

    if (myfile == nullptr) {
      cout<<"Error opening file: "<<strFileName<<endl;
      std::exit(EXIT_FAILURE);
    }  

    fprintf(myfile,"# vtk DataFile Version 2.0\n");
    fprintf(myfile,"Generated by FullC0ntact\n");
    fprintf(myfile,"ASCII\n");
    fprintf(myfile,"DATASET UNSTRUCTURED_GRID\n");
    fprintf(myfile,"POINTS 4 double\n");      

    fprintf(myfile,"%f %f %f \n",t.va_.x,
                                 t.va_.y,
                                 t.va_.z);    

    fprintf(myfile,"%f %f %f \n",t.vb_.x,
                                 t.vb_.y,
                                 t.vb_.z);    

    fprintf(myfile,"%f %f %f \n",t.vc_.x,
                                 t.vc_.y,
                                 t.vc_.z);    

    fprintf(myfile,"%f %f %f \n",t.vd_.x,
                                 t.vd_.y,
                                 t.vd_.z);    

    fprintf(myfile,"CELLS %i %i\n",1, 5);

      fprintf(myfile,"4  %i %i %i %i\n",0,1,2,3);    

    fprintf(myfile,"CELL_TYPES %i\n",1);        

    fprintf(myfile,"10\n");          

    fprintf(myfile,"POINT_DATA %i\n",4);
    fprintf(myfile,"SCALARS distance double 1\n");
    fprintf(myfile,"LOOKUP_TABLE default\n");      
    for(int i=0;i<4;i++)
    {
      fprintf(myfile,"%f \n",1.0f);      
    }//end for

    fprintf(myfile, "SCALARS ivt int 1\n");
    fprintf(myfile, "LOOKUP_TABLE default\n");
    for (int i = 0; i<4; i++)
    {
      fprintf(myfile, "%i\n", i);
    }//end for

    //close the file
    fclose (myfile);  

  }

  void CVtkWriter::WriteSpringMesh(CUnstrGrid &Grid,const char *strFileName)
  {

    using namespace std;
    FILE * myfile = fopen(strFileName,"w");

    if (myfile == NULL) {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }  

    int i;
    fprintf(myfile,"# vtk DataFile Version 2.0\n");
    fprintf(myfile,"Generated by FullC0ntact\n");
    fprintf(myfile,"ASCII\n");
    fprintf(myfile,"DATASET UNSTRUCTURED_GRID\n");
    fprintf(myfile,"POINTS %i double\n",Grid.nvt_);      

    //fprintf(myfile,"3 %i %i %i \n",pMesh.m_pFaces[i][0]+ioffset, pMesh.m_pFaces[i][1]+ioffset, pMesh.m_pFaces[i][2]+ioffset);  

    for(i=0;i<Grid.nvt_;i++)
    {
      fprintf(myfile,"%f %f %f \n",Grid.vertexCoords_[i].x,Grid.vertexCoords_[i].y,Grid.vertexCoords_[i].z);    
    }//end for

    fprintf(myfile,"CELLS %i %i\n",Grid.nel_,Grid.nel_*9);
    for(i=0;i<Grid.nel_;i++)
    {
      fprintf(myfile,"8  %i %i %i %i %i %i %i %i\n",Grid.hexas_[i].hexaVertexIndices_[0],Grid.hexas_[i].hexaVertexIndices_[1],Grid.hexas_[i].hexaVertexIndices_[2],
          Grid.hexas_[i].hexaVertexIndices_[3],Grid.hexas_[i].hexaVertexIndices_[4],Grid.hexas_[i].hexaVertexIndices_[5],
          Grid.hexas_[i].hexaVertexIndices_[6],Grid.hexas_[i].hexaVertexIndices_[7]);    
    }//end for

    fprintf(myfile,"CELL_TYPES %i\n",Grid.nel_);        
    for(i=0;i<Grid.nel_;i++)
    {
      fprintf(myfile,"12\n");          
    }//end for

    fprintf(myfile,"POINT_DATA %i\n",Grid.nvt_);
    fprintf(myfile,"SCALARS distance double 1\n");
    fprintf(myfile,"LOOKUP_TABLE default\n");      
    for(int i=0;i<Grid.nvt_;i++)
    {
      fprintf(myfile,"%f \n",Grid.m_myTraits[i].distance);      
    }//end for

    fprintf(myfile,"SCALARS inout int 1\n");
    fprintf(myfile,"LOOKUP_TABLE default\n");    
    for(int i=0;i<Grid.nvt_;i++)
    {
      fprintf(myfile,"%i\n",Grid.m_myTraits[i].iTag);        
    }//end for

    fprintf(myfile, "SCALARS ivt int 1\n");
    fprintf(myfile, "LOOKUP_TABLE default\n");
    for (int i = 0; i<Grid.nvt_; i++)
    {
      fprintf(myfile, "%i\n", i);
    }//end for


    fprintf(myfile,"VECTORS Velocity double\n");  
    for(int i=0;i<Grid.nvt_;i++)
    {
      fprintf(myfile,"%f %f %f\n",Grid.m_myTraits[i].vel_.x,Grid.m_myTraits[i].vel_.y,Grid.m_myTraits[i].vel_.z);    
    }//end for  

    fprintf(myfile,"VECTORS Force double\n");  
    for(int i=0;i<Grid.nvt_;i++)
    {
      fprintf(myfile,"%f %f %f\n",Grid.m_myTraits[i].force_.x,Grid.m_myTraits[i].force_.y,Grid.m_myTraits[i].force_.z);    
    }//end for  

    fprintf(myfile,"CELL_DATA %i\n",Grid.nel_);
    fprintf(myfile,"SCALARS dummy2 double 1\n");    
    fprintf(myfile,"LOOKUP_TABLE default\n");      
    for(int k=0;k<Grid.nel_;k++)
    {
      fprintf(myfile,"-1\n");
    }//end for

    //close the file
    fclose (myfile);  

  }

  void CVtkWriter::WriteUnstrFaces(CUnstrGrid &Grid,const char *strFileName)
  {

    using namespace std;
    FILE * myfile = fopen(strFileName,"w");

    if (myfile == NULL) {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }  

    int i;
    fprintf(myfile,"# vtk DataFile Version 2.0\n");
    fprintf(myfile,"Generated by FullC0ntact\n");
    fprintf(myfile,"ASCII\n");
    fprintf(myfile,"DATASET UNSTRUCTURED_GRID\n");
    fprintf(myfile,"POINTS %i double\n",Grid.nvt_);      

    //fprintf(myfile,"3 %i %i %i \n",pMesh.m_pFaces[i][0]+ioffset, pMesh.m_pFaces[i][1]+ioffset, pMesh.m_pFaces[i][2]+ioffset);  

    for(i=0;i<Grid.nvt_;i++)
    {
      fprintf(myfile,"%f %f %f \n",Grid.vertexCoords_[i].x,Grid.vertexCoords_[i].y,Grid.vertexCoords_[i].z);    
    }//end for

    //int nfaces = Grid.facesAtBoundary_.size();
    ParFileInfo &xx = Grid.parInfo_->front();
    int nfaces = xx.faces_.size();

    fprintf(myfile,"CELLS %i %i\n",nfaces,nfaces*5);
    for(i=0;i<nfaces;i++)
    {
      int i0 = xx.verticesAtFace_[i].faceVertexIndices_[0];
      int i1 = xx.verticesAtFace_[i].faceVertexIndices_[1];
      int i2 = xx.verticesAtFace_[i].faceVertexIndices_[2];
      int i3 = xx.verticesAtFace_[i].faceVertexIndices_[3];
      fprintf(myfile,"4  %i %i %i %i\n",i0,i1,i2,i3);
    }//end for

    fprintf(myfile,"CELL_TYPES %i\n",nfaces);        
    for(i=0;i<nfaces;i++)
    {
      fprintf(myfile,"9\n");          
    }//end for

    //close the file
    fclose (myfile);  

  }

  void CVtkWriter::WriteUnstr(CUnstrGrid &Grid,const char *strFileName)
  {

    using namespace std;
    FILE * myfile = fopen(strFileName,"w");

    if (myfile == NULL) {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }  

    int i;
    fprintf(myfile,"# vtk DataFile Version 2.0\n");
    fprintf(myfile,"Generated by FullC0ntact\n");
    fprintf(myfile,"ASCII\n");
    fprintf(myfile,"DATASET UNSTRUCTURED_GRID\n");
    fprintf(myfile,"POINTS %i double\n",Grid.nvt_);      

    //fprintf(myfile,"3 %i %i %i \n",pMesh.m_pFaces[i][0]+ioffset, pMesh.m_pFaces[i][1]+ioffset, pMesh.m_pFaces[i][2]+ioffset);  

    for(i=0;i<Grid.nvt_;i++)
    {
      fprintf(myfile,"%f %f %f \n",Grid.vertexCoords_[i].x,Grid.vertexCoords_[i].y,Grid.vertexCoords_[i].z);    
    }//end for

    fprintf(myfile,"CELLS %i %i\n",Grid.nel_,Grid.nel_*9);
    for(i=0;i<Grid.nel_;i++)
    {
      fprintf(myfile,"8  %i %i %i %i %i %i %i %i\n",Grid.hexas_[i].hexaVertexIndices_[0],Grid.hexas_[i].hexaVertexIndices_[1],Grid.hexas_[i].hexaVertexIndices_[2],
          Grid.hexas_[i].hexaVertexIndices_[3],Grid.hexas_[i].hexaVertexIndices_[4],Grid.hexas_[i].hexaVertexIndices_[5],
          Grid.hexas_[i].hexaVertexIndices_[6],Grid.hexas_[i].hexaVertexIndices_[7]);    
    }//end for

    fprintf(myfile,"CELL_TYPES %i\n",Grid.nel_);        
    for(i=0;i<Grid.nel_;i++)
    {
      fprintf(myfile,"12\n");          
    }//end for

    fprintf(myfile,"POINT_DATA %i\n",Grid.nvt_);
    fprintf(myfile,"SCALARS distance double 1\n");
    fprintf(myfile,"LOOKUP_TABLE default\n");      
    for(int i=0;i<Grid.nvt_;i++)
    {
      fprintf(myfile,"%f \n",Grid.m_myTraits[i].distance);      
    }//end for

    fprintf(myfile,"SCALARS dist2 double 1\n");
    fprintf(myfile,"LOOKUP_TABLE default\n");      
    for(int i=0;i<Grid.nvt_;i++)
    {
      fprintf(myfile,"%f \n",Grid.m_myTraits[i].dist2);      
    }//end for

    fprintf(myfile,"SCALARS inout int 1\n");
    fprintf(myfile,"LOOKUP_TABLE default\n");    
    for(int i=0;i<Grid.nvt_;i++)
    {
      fprintf(myfile,"%i\n",Grid.m_myTraits[i].iTag);        
    }//end for

    fprintf(myfile, "SCALARS ibndry int 1\n");
    fprintf(myfile, "LOOKUP_TABLE default\n");
    for (int i = 0; i<Grid.nvt_; i++)
    {
      fprintf(myfile,"%i\n",Grid.m_myTraits[i].iX);        
    }//end for

    fprintf(myfile, "SCALARS ivt int 1\n");
    fprintf(myfile, "LOOKUP_TABLE default\n");
    for (int i = 0; i<Grid.nvt_; i++)
    {
      fprintf(myfile, "%i\n", i);
    }//end for


//    fprintf(myfile,"VECTORS Normal double\n");  
//    for(int i=0;i<Grid.nvt_;i++)
//    {
//      fprintf(myfile,"%f %f %f\n",Grid.m_myTraits[i].vNormal.x,Grid.m_myTraits[i].vNormal.y,Grid.m_myTraits[i].vNormal.z);    
//    }//end for  
//
//    fprintf(myfile,"CELL_DATA %i\n",Grid.elemVol_.size());
//    fprintf(myfile,"SCALARS Volume double 1\n");    
//    fprintf(myfile,"LOOKUP_TABLE default\n");      
//    for(auto k=0; k < Grid.elemVol_.size(); k++)
//    {
//      fprintf(myfile,"%f\n", Grid.elemVol_[k]);
//    }//end for

    fprintf(myfile,"CELL_DATA %i\n",Grid.nel_);
    fprintf(myfile,"SCALARS iel int 1\n");    
    fprintf(myfile,"LOOKUP_TABLE default\n");      
    for(auto k=0; k < Grid.nel_; k++)
    {
      fprintf(myfile,"%i\n", k);
    }//end for

//    fprintf(myfile,"SCALARS Volume double 1\n");    
//    fprintf(myfile,"LOOKUP_TABLE default\n");      
//    for(auto k=0; k < Grid.elemVol_.size(); k++)
//    {
//      fprintf(myfile,"%f\n", Grid.elemVol_[k]);
//    }//end for

    //close the file
    fclose (myfile);  

  }

  void CVtkWriter::WriteParamLine(ParamLiner &line, std::vector<Vec3> f, const char *strFileName)
  {
    using namespace std;
    ofstream myfile(strFileName);

    //check
    if(!myfile.is_open())
    {
      cout<<"Error opening file: "<<"output.vtk"<<endl;
      exit(0);
    }//end if

    int i;
    myfile<<"# vtk DataFile Version 2.0"<<endl;
    myfile<<"Generated by InShape 2.x"<<endl;
    myfile<<"ASCII"<<endl;
    myfile<<"DATASET UNSTRUCTURED_GRID"<<endl;
    myfile<<"POINTS "<<line.vertices_.size()<<" double"<<endl;
    myfile.precision(7);

    int iVerts = line.vertices_.size();
    Vec3 origin = line.center_;

    for(i=0;i<iVerts;i++)
    {
      myfile<<line.vertices_[i].x + origin.x << " " <<
              line.vertices_[i].y + origin.y << " "<<
              line.vertices_[i].z + origin.z <<endl;
    }//end for
    myfile.precision();

    int iCells = line.segments_.size();
    myfile<<"CELLS "<<iCells<<" "<<iCells*3<<endl;

    for(i=0;i<iCells;i++)
    {
      myfile <<2<<" "<<line.faces_[i].first<<" "<<line.faces_[i].second<<" "<<endl;
    }//end for

    myfile<<"CELL_TYPES "<<iCells<<endl;
    for(i=0;i<iCells;i++)
    {
      myfile<<3<<endl;
    }//end for

    myfile<<"POINT_DATA " << iVerts <<endl;
    myfile<<"SCALARS vids int 1"<<endl;
    myfile<<"LOOKUP_TABLE default"<<endl;

    for(int i=0;i<iVerts;i++)
    {
      myfile<<i<<endl;
    }//end for

    myfile<<"VECTORS force double"<<endl;
    for(int i=0;i<iVerts;i++)
    {
      myfile<<f[i].x << " " <<
              f[i].y << " "<<
              f[i].z <<endl;
    }//end for

    //close the file
    myfile.close();

  }

  void CVtkWriter::WriteParamLine(ParamLiner& line, const char* strFileName)
  {
    using namespace std;
    ofstream myfile(strFileName);

    //check
    if(!myfile.is_open())
    {
      cout<<"Error opening file: "<<"output.vtk"<<endl;
      exit(0);
    }//end if

    int i;
    myfile<<"# vtk DataFile Version 2.0"<<endl;
    myfile<<"Generated by InShape 2.x"<<endl;
    myfile<<"ASCII"<<endl;
    myfile<<"DATASET UNSTRUCTURED_GRID"<<endl;
    myfile<<"POINTS "<<line.vertices_.size()<<" double"<<endl;
    myfile.precision(7);

    int iVerts = line.vertices_.size();
    Vec3 origin = line.center_;

    for(i=0;i<iVerts;i++)
    {
      myfile<<line.vertices_[i].x + origin.x << " " <<
              line.vertices_[i].y + origin.y << " "<<
              line.vertices_[i].z + origin.z <<endl;
    }//end for
    myfile.precision();

    int iCells = line.segments_.size();
    myfile<<"CELLS "<<iCells<<" "<<iCells*3<<endl;

    for(i=0;i<iCells;i++)
    {
      myfile <<2<<" "<<line.faces_[i].first<<" "<<line.faces_[i].second<<" "<<endl;
    }//end for

    myfile<<"CELL_TYPES "<<iCells<<endl;
    for(i=0;i<iCells;i++)
    {
      myfile<<3<<endl;
    }//end for

    myfile<<"POINT_DATA " << iVerts <<endl;
    myfile<<"SCALARS vids int 1"<<endl;
    myfile<<"LOOKUP_TABLE default"<<endl;

    for(int i=0;i<iVerts;i++)
    {
      myfile<<i<<endl;
    }//end for

    //close the file
    myfile.close();

  }

  void CVtkWriter::WriteUnstr(CUnstrGrid &Grid,std::vector<Real> &element,const char *strFileName)
  {
    using namespace std;
    ofstream myfile(strFileName);

    //check
    if(!myfile.is_open())
    {
      cout<<"Error opening file: "<<"output.vtk"<<endl;
      exit(0);
    }//end if
    int i,j;
    myfile<<"# vtk DataFile Version 2.0"<<endl;
    myfile<<"Generated by InShape 2.x"<<endl;
    myfile<<"ASCII"<<endl;
    myfile<<"DATASET UNSTRUCTURED_GRID"<<endl;
    myfile<<"POINTS "<<Grid.nvt_<<" double"<<endl;
    myfile.precision(7);
    for(i=0;i<Grid.nvt_;i++)
    {
      myfile<<Grid.vertexCoords_[i].x<<" "<<Grid.vertexCoords_[i].y<<" "<<Grid.vertexCoords_[i].z<<endl;
    }//end for
    myfile.precision();
    myfile<<"CELLS "<<Grid.nel_<<" "<<Grid.nel_*9<<endl;
    for(i=0;i<Grid.nel_;i++)
    {
      myfile <<8<<" ";
      for(j=0;j<8;j++)
        myfile<<Grid.hexas_[i].hexaVertexIndices_[j]<<" ";
      myfile<<endl;
    }//end for
    myfile<<"CELL_TYPES "<<Grid.nel_<<endl;
    for(i=0;i<Grid.nel_;i++)
    {
      myfile<<12<<endl;
    }//end for

    myfile<<"POINT_DATA "<<Grid.nvt_<<endl;
    myfile<<"SCALARS "<<"distance double 1"<<endl;
    myfile<<"LOOKUP_TABLE default"<<endl;
    for(int i=0;i<Grid.nvt_;i++)
    {
      myfile<<Grid.m_myTraits[i].distance<<endl;
    }//end for

    myfile<<"SCALARS "<<"inout int 1"<<endl;
    myfile<<"LOOKUP_TABLE default"<<endl;
    for(int i=0;i<Grid.nvt_;i++)
    {
      myfile<<Grid.m_myTraits[i].iTag<<endl;
    }//end for

    myfile<<"VECTORS Normal double"<<endl;
    for(int i=0;i<Grid.nvt_;i++)
    {
      myfile<<Grid.m_myTraits[i].vNormal<<endl;
    }//end for


    myfile<<"CELL_DATA "<<Grid.nel_<<endl;
    myfile<<"SCALARS "<<"dummy2 double 1"<<endl;
    myfile<<"LOOKUP_TABLE default"<<endl;
    for(int k=0;k<Grid.nel_;k++)
    {
      myfile<<element[k]<<endl;
    }//end for

    //close the file
    myfile.close();

  }

  void CVtkWriter::WriteModel(Model3D &pModel,const char *strFileName)
  {
    using namespace std;
    ofstream myfile(strFileName);

    //check
    if(!myfile.is_open())
    {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }//end if

    int iVerts=0;
    int iPolys=0;
    vector<Mesh3D>::iterator mIter;
    int icount = 0;
    for(mIter=pModel.meshes_.begin();mIter!=pModel.meshes_.end();mIter++)
    {
      Mesh3D &pMesh=*mIter;
      iVerts+=pMesh.numVerts_;
      iPolys+=pMesh.numFaces_;
      icount++;
    }
    myfile<<"# vtk DataFile Version 2.0"<<endl;
    myfile<<"Generated by InShape 2.x"<<endl;
    myfile<<"ASCII"<<endl;
    myfile<<"DATASET POLYDATA"<<endl;
    myfile<<"POINTS "<<iVerts<<" double"<<endl;
    myfile.precision(7);
    icount = 0;
    for(mIter=pModel.meshes_.begin();mIter!=pModel.meshes_.end();mIter++)
    {
      Mesh3D &pMesh=*mIter;
      for(int i=0;i<pMesh.vertices_.size();i++)
      {
        myfile<<pMesh.vertices_[i].x<<" "<<pMesh.vertices_[i].y<<" "<<pMesh.vertices_[i].z<<endl;
      }//end for
      icount++;
    }//for
    int lengthPolyList=4*iPolys;
    myfile<<"POLYGONS "<<iPolys<<" "<<lengthPolyList<<endl;
    icount = 0;
    for(mIter=pModel.meshes_.begin();mIter!=pModel.meshes_.end();mIter++)
    {
      Mesh3D &pMesh=*mIter;
      for(int i=0;i<pMesh.numFaces_;i++)
      {
        myfile<<3<<" "<<pMesh.faces_[i][0]+icount*pMesh.getNumVertices()
          <<" "<<pMesh.faces_[i][1]+icount*pMesh.getNumVertices()
          <<" "<<pMesh.faces_[i][2]+icount*pMesh.getNumVertices()<<endl;
      }//end for
      icount++;
    }//for  

  }//end

  void CVtkWriter::WriteRigidBodiesEx(std::vector<OBB3r*> &pRigidBodies,const char *strFileName)
  {
    using namespace std;
    FILE * myfile = fopen(strFileName,"w");

    if (myfile == NULL) {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }

    //total number of vertices
    int iVerts=0;
    //total number of polygons
    int iPolys=0;
    //iterators for models and submeshes
    vector<Mesh3D>::iterator meshIter;
    vector<Model3D>::iterator modelIter;
    vector<OBB3r*>::iterator rIter;
    vector<Model3D> pModels;
    vector<int> vVerts;
    vector<int>::iterator vertsIter;
    int ioffset=0;

    for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
    {

      CTriangulator<Real, OBB3<Real> > triangulator;
      OBB3r *pBox = *rIter;
      Model3D model_out=triangulator.Triangulate(*pBox);
      pModels.push_back(model_out);
    }	

    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      int ivertsModel=0;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        iVerts+=pMesh.numVerts_;
        iPolys+=pMesh.numFaces_;
        ivertsModel+=pMesh.numVerts_;
      }
      vVerts.push_back(ivertsModel);
    }

    fprintf(myfile,"# vtk DataFile Version 2.0\n");
    fprintf(myfile,"Generated by InShape 2.x\n");
    fprintf(myfile,"ASCII\n");
    fprintf(myfile,"DATASET POLYDATA\n");
    fprintf(myfile,"POINTS %i double\n",iVerts);

    //write the actual vertex data
    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.vertices_.size();i++)
        {
          fprintf(myfile,"%f %f %f \n",pMesh.vertices_[i].x,pMesh.vertices_[i].y,pMesh.vertices_[i].z);
        }//end for
      }//for
    }//end for

    int lengthPolyList=4*iPolys;
    fprintf(myfile,"POLYGONS %i %i \n",iPolys,lengthPolyList);
    vertsIter = vVerts.begin();
    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      int ivertsModel = *vertsIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.numFaces_;i++)
        {
          fprintf(myfile,"3 %i %i %i \n",pMesh.faces_[i][0]+ioffset, pMesh.faces_[i][1]+ioffset, pMesh.faces_[i][2]+ioffset);
        }//end for faces
      }//for submeshes
      ioffset+=ivertsModel;
      vertsIter++;
    }//for models

    fprintf(myfile,"POINT_DATA %i \n",iVerts);
    fprintf(myfile,"SCALARS dummy double 1 \n");
    fprintf(myfile,"LOOKUP_TABLE default\n");
    int modelid=0;
    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.vertices_.size();i++)
        {
          fprintf(myfile,"%f\n",(pMesh.vertices_[0]-pMesh.vertices_[i]).mag());
        }//end for
      }//for
      modelid++;
    }//end for
    fprintf(myfile,"CELL_DATA %i \n",iPolys);
    fprintf(myfile,"SCALARS CellID int 1\n");
    fprintf(myfile,"LOOKUP_TABLE default\n");
    int cellid=0;
    for(modelIter = pModels.begin(),rIter=pRigidBodies.begin();modelIter!=pModels.end();modelIter++,rIter++)
    {
      Model3D &pModel = *modelIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.numFaces_;i++)
        {
          fprintf(myfile,"%i \n",cellid);
        }//end for faces
      }//for submeshes
      cellid++;
    }//for models

    fclose (myfile);

  }

  void CVtkWriter::WriteSolids(std::vector<Model3D> &pSolids,const char *strFileName)
  {
    using namespace std;
    ofstream myfile(strFileName);

    //total number of vertices
    int iVerts=0;
    //total number of polygons
    int iPolys=0;
    //iterators for models and submeshes
    vector<Mesh3D>::iterator meshIter;
    vector<Model3D>::iterator modelIter;
    vector<int> vVerts;
    vector<int>::iterator vertsIter;
    int ioffset=0;

    //check
    if(!myfile.is_open())
    {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }//end if

    for(modelIter = pSolids.begin();modelIter!=pSolids.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      int ivertsModel=0;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        iVerts+=pMesh.numVerts_;
        iPolys+=pMesh.numFaces_;
        ivertsModel+=pMesh.numVerts_;
      }
      vVerts.push_back(ivertsModel);
    }

    myfile<<"# vtk DataFile Version 2.0"<<endl;
    myfile<<"Generated by InShape 2.x"<<endl;
    myfile<<"ASCII"<<endl;
    myfile<<"DATASET POLYDATA"<<endl;
    myfile<<"POINTS "<<iVerts<<" double"<<endl;
    myfile.precision(7);
    //write the actual vertex data
    for(modelIter = pSolids.begin();modelIter!=pSolids.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.vertices_.size();i++)
        {
          myfile<<pMesh.vertices_[i].x<<" "<<pMesh.vertices_[i].y<<" "<<pMesh.vertices_[i].z<<endl;
        }//end for
      }//for
    }//end for

    int lengthPolyList=4*iPolys;
    myfile<<"POLYGONS "<<iPolys<<" "<<lengthPolyList<<endl;
    vertsIter = vVerts.begin();
    for(modelIter = pSolids.begin();modelIter!=pSolids.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      int ivertsModel = *vertsIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.numFaces_;i++)
        {
          myfile<<3<<" "<<pMesh.faces_[i][0]+ioffset<<" "
            <<pMesh.faces_[i][1]+ioffset<<" "<<pMesh.faces_[i][2]+ioffset<<endl;
        }//end for faces
      }//for submeshes
      ioffset+=ivertsModel;
      vertsIter++;
    }//for models
    myfile.close();
  }

  void CVtkWriter::WriteSpheresMesh(std::vector<RigidBody*> &pRigidBodies, const char *strFileName)
  {
    using namespace std;
    FILE * myfile = fopen(strFileName, "w");

    if (myfile == NULL) {
      cout << "Error opening file: " << strFileName << endl;
      exit(0);
    }

    //total number of vertices
    int iVerts = 0;
    //total number of polygons
    int iPolys = 0;
    //iterators for models and submeshes
    vector<Mesh3D>::iterator meshIter;
    vector<Model3D>::iterator modelIter;
    vector<RigidBody*>::iterator rIter;
    vector<Model3D> pModels;
    vector<int> vVerts;
    vector<int>::iterator vertsIter;
    int ioffset = 0;

    for (auto& j : pRigidBodies)
    {
      RigidBody &body = *(j);
      if (body.shapeId_ == RigidBody::SPHERE)
      {
        CTriangulator<Real, Sphere<Real> > triangulator;
        Spherer *pSphere = dynamic_cast<Spherer*>(body.shape_);
        Model3D model_out = triangulator.Triangulate(*pSphere);
        model_out.meshes_[0].transform_ = body.getTransformationMatrix();
        model_out.meshes_[0].com_ = body.com_;
        model_out.meshes_[0].TransformModelWorld();
        pModels.push_back(model_out);
      }
      else if (body.shapeId_ == RigidBody::COMPOUND)
      {
        RigidBody *pBody = &body;
        CompoundBody *b = dynamic_cast<CompoundBody*>(pBody);
        for (auto &i : b->rigidBodies_)
        {
          RigidBody* comp = i;
          VECTOR3 trans = comp->getTransformedPosition();
          CTriangulator<Real, Sphere<Real> > triangulator;
          Spherer *pSphere = dynamic_cast<Spherer*>(comp->shape_);
          Model3D model_out = triangulator.Triangulate(*pSphere);
          model_out.meshes_[0].transform_ = body.getTransformationMatrix();
          model_out.meshes_[0].com_ = body.com_;
          model_out.meshes_[0].TransformModelWorld();
          pModels.push_back(model_out);
        }
      }
    }

    for (modelIter = pModels.begin(); modelIter != pModels.end(); modelIter++)
    {
      Model3D &pModel = *modelIter;
      int ivertsModel = 0;
      for (meshIter = pModel.meshes_.begin(); meshIter != pModel.meshes_.end(); meshIter++)
      {
        Mesh3D &pMesh = *meshIter;
        iVerts += pMesh.numVerts_;
        iPolys += pMesh.numFaces_;
        ivertsModel += pMesh.numVerts_;
      }
      vVerts.push_back(ivertsModel);
    }

    fprintf(myfile, "# vtk DataFile Version 2.0\n");
    fprintf(myfile, "Generated by InShape 2.x\n");
    fprintf(myfile, "ASCII\n");
    fprintf(myfile, "DATASET POLYDATA\n");
    fprintf(myfile, "POINTS %i double\n", iVerts);

    //write the actual vertex data
    for (modelIter = pModels.begin(); modelIter != pModels.end(); modelIter++)
    {
      Model3D &pModel = *modelIter;
      for (meshIter = pModel.meshes_.begin(); meshIter != pModel.meshes_.end(); meshIter++)
      {
        Mesh3D &pMesh = *meshIter;
        for (int i = 0; i<pMesh.vertices_.size(); i++)
        {
          fprintf(myfile, "%f %f %f \n", pMesh.vertices_[i].x, pMesh.vertices_[i].y, pMesh.vertices_[i].z);
        }//end for
      }//for
    }//end for

    int lengthPolyList = 4 * iPolys;
    fprintf(myfile, "POLYGONS %i %i \n", iPolys, lengthPolyList);
    vertsIter = vVerts.begin();
    for (modelIter = pModels.begin(); modelIter != pModels.end(); modelIter++)
    {
      Model3D &pModel = *modelIter;
      int ivertsModel = *vertsIter;
      for (meshIter = pModel.meshes_.begin(); meshIter != pModel.meshes_.end(); meshIter++)
      {
        Mesh3D &pMesh = *meshIter;
        for (int i = 0; i<pMesh.numFaces_; i++)
        {
          fprintf(myfile, "3 %i %i %i \n", pMesh.faces_[i][0] + ioffset, pMesh.faces_[i][1] + ioffset, pMesh.faces_[i][2] + ioffset);
        }//end for faces
        ioffset += pMesh.numVerts_;
      }//for submeshes
      vertsIter++;
    }//for models

    fprintf(myfile, "POINT_DATA %i \n", iVerts);
    fprintf(myfile, "SCALARS dummy double 1 \n");
    fprintf(myfile, "LOOKUP_TABLE default\n");
    int modelid = 0;
    for (modelIter = pModels.begin(); modelIter != pModels.end(); modelIter++)
    {
      Model3D &pModel = *modelIter;
      for (meshIter = pModel.meshes_.begin(); meshIter != pModel.meshes_.end(); meshIter++)
      {
        Mesh3D &pMesh = *meshIter;
        for (int i = 0; i<pMesh.vertices_.size(); i++)
        {
          fprintf(myfile, "%f\n", (pMesh.vertices_[0] - pMesh.vertices_[i]).mag());
        }//end for
      }//for
      modelid++;
    }//end for
    fprintf(myfile, "CELL_DATA %i \n", iPolys);
    fprintf(myfile, "SCALARS CellID int 1\n");
    fprintf(myfile, "LOOKUP_TABLE default\n");
    int cellid = 0;
    for (modelIter = pModels.begin(), rIter = pRigidBodies.begin(); modelIter != pModels.end(); modelIter++, rIter++)
    {
      RigidBody &body = *(*rIter);
      Model3D &pModel = *modelIter;
      for (meshIter = pModel.meshes_.begin(); meshIter != pModel.meshes_.end(); meshIter++)
      {
        Mesh3D &pMesh = *meshIter;
        for (int i = 0; i<pMesh.numFaces_; i++)
        {
          fprintf(myfile, "%i \n", cellid);
        }//end for faces
      }//for submeshes
      cellid++;
    }//for models

    fprintf(myfile, "SCALARS ContactGroup int 1\n");
    fprintf(myfile, "LOOKUP_TABLE default\n");
    for (modelIter = pModels.begin(), rIter = pRigidBodies.begin(); modelIter != pModels.end(); modelIter++, rIter++)
    {
      RigidBody &body = *(*rIter);
      Model3D &pModel = *modelIter;
      for (meshIter = pModel.meshes_.begin(); meshIter != pModel.meshes_.end(); meshIter++)
      {
        Mesh3D &pMesh = *meshIter;
        for (int i = 0; i<pMesh.numFaces_; i++)
        {
          fprintf(myfile, "%i \n", body.group_);
        }//end for faces
      }//for submeshes
      cellid++;
    }//for models

    fprintf(myfile, "SCALARS StackHeight int 1\n");
    fprintf(myfile, "LOOKUP_TABLE default\n");
    for (modelIter = pModels.begin(), rIter = pRigidBodies.begin(); modelIter != pModels.end(); modelIter++, rIter++)
    {
      RigidBody &body = *(*rIter);
      Model3D &pModel = *modelIter;
      for (meshIter = pModel.meshes_.begin(); meshIter != pModel.meshes_.end(); meshIter++)
      {
        Mesh3D &pMesh = *meshIter;
        for (int i = 0; i<pMesh.numFaces_; i++)
        {
          fprintf(myfile, "%i \n", body.height_);
        }//end for faces
      }//for submeshes
      cellid++;
    }//for models	

    fclose(myfile);

  }

  void CVtkWriter::WriteRigidBodies(std::vector<RigidBody*> &pRigidBodies, const char *strFileName, bool writeSpheres)
  {
    using namespace std;
    FILE * myfile = fopen(strFileName,"w");

    if (myfile == nullptr) {
      cout<<"Error opening file: "<<strFileName<<endl;
      std::exit(EXIT_FAILURE);
    }

    //total number of vertices
    int iVerts=0;
    //total number of polygons
    int iPolys=0;
    //iterators for models and submeshes
    vector<Mesh3D>::iterator meshIter;
    vector<Model3D>::iterator modelIter;
    vector<RigidBody*>::iterator rIter;
    vector<Model3D> pModels;
    vector<int> vVerts;
    vector<int>::iterator vertsIter;
    int ioffset=0;

    for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
    {
      RigidBody &body = *(*rIter);
      if(body.shapeId_ == RigidBody::BOX)
      {
        CTriangulator<Real, OBB3<Real> > triangulator;
        OBB3r *pBox = dynamic_cast<OBB3r*>(body.shape_);
        Model3D model_out=triangulator.Triangulate(*pBox);
        model_out.meshes_[0].transform_ = body.getTransformationMatrix();
        model_out.meshes_[0].com_ =body.com_;
        model_out.meshes_[0].TransformModelWorld();
        pModels.push_back(model_out);
      }
      else if(body.shapeId_ == RigidBody::SPHERE)
      {
        if (!writeSpheres)
          continue;
        CTriangulator<Real, Sphere<Real> > triangulator;
        Spherer *pSphere = dynamic_cast<Spherer*>(body.shape_);
        Model3D model_out=triangulator.Triangulate(*pSphere);
        model_out.meshes_[0].transform_ =body.getTransformationMatrix();
        model_out.meshes_[0].com_ =body.com_;
        model_out.meshes_[0].TransformModelWorld();
        pModels.push_back(model_out);
      }
      //    else if(body.shapeId_ == RigidBody::COMPOUND)
      //    {
      //      RigidBody *pBody = &body;
      //      CompoundBody *b = dynamic_cast<CompoundBody*>(pBody);
      //      for( auto &i : b->rigidBodies_)
      //      {
      //        RigidBody* comp = i;
      //        CTriangulator<Real, Sphere<Real> > triangulator;
      //        Spherer *pSphere = dynamic_cast<Spherer*>(comp->shape_);
      //        C3DModel model_out=triangulator.Triangulate(*pSphere);
      //        model_out.m_vMeshes[0].m_matTransform =comp->getTransformationMatrix();
      //        model_out.m_vMeshes[0].m_vOrigin =comp->com_;
      //        model_out.m_vMeshes[0].TransformModelWorld();
      //        pModels.push_back(model_out);
      //      }
      //    }
      else if(body.shapeId_ == RigidBody::CYLINDERBDRY || body.shapeId_ == RigidBody::HOLLOWCYLINDER)
      {
        CTriangulator<Real, Cylinder<Real> > triangulator;
        BoundaryCylr *pCylinder = dynamic_cast<BoundaryCylr *>(body.shape_);    
        Cylinderr &cyl = pCylinder->cylinder_;
        Model3D model_out=triangulator.Triangulate(cyl);
        model_out.meshes_[0].transform_ =body.getTransformationMatrix();
        model_out.meshes_[0].com_ =body.com_;
        model_out.meshes_[0].TransformModelWorld();
        pModels.push_back(model_out);
      }        
      else if(body.shapeId_ == RigidBody::CYLINDER)
      {
        CTriangulator<Real, Cylinder<Real> > triangulator;
        Cylinderr *pCylinder = dynamic_cast<Cylinderr*>(body.shape_);
        Model3D model_out=triangulator.Triangulate(*pCylinder);
        model_out.meshes_[0].transform_ =body.getTransformationMatrix();
        model_out.meshes_[0].com_ =body.com_;
        model_out.meshes_[0].TransformModelWorld();
        pModels.push_back(model_out);
      }    
      else if(body.shapeId_ == RigidBody::MESH)
      {
        MeshObject<Real> *pMeshObject = dynamic_cast<MeshObject<Real>*>(body.shape_);
        Model3D model_out=pMeshObject->getModel();
        //actually loop over all meshes and transform them
        for(int imesh=0;imesh < model_out.meshes_.size();imesh++)
        {
          model_out.meshes_[imesh].transform_ = body.getTransformationMatrix();
          model_out.meshes_[imesh].com_ = body.com_;
          model_out.meshes_[imesh].TransformModelWorld();
        }
        pModels.push_back(model_out);

      }
      else if (body.shapeId_ == RigidBody::CGALMESH)
      {

        MeshObject<Real, cgalKernel> *pMeshObject = dynamic_cast<MeshObject<Real, cgalKernel> *>(body.shape_);
        std::vector<Vec3> out_vertices;
        std::vector<TriFace> out_faces;
        Model3D model_out = pMeshObject->getModel();

        for (int imesh = 0; imesh < model_out.meshes_.size(); imesh++)
        {
          model_out.meshes_[imesh].transform_ = body.getTransformationMatrix();
          model_out.meshes_[imesh].com_ = body.com_;
          model_out.meshes_[imesh].TransformModelWorld();
        }
        pModels.push_back(model_out);
      }
    }

    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      int ivertsModel=0;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        iVerts+=pMesh.numVerts_;
        iPolys+=pMesh.numFaces_;
        ivertsModel+=pMesh.numVerts_;
      }
      vVerts.push_back(ivertsModel);
    }

    fprintf(myfile,"# vtk DataFile Version 2.0\n");
    fprintf(myfile,"Generated by InShape 2.x\n");
    fprintf(myfile,"ASCII\n");
    fprintf(myfile,"DATASET POLYDATA\n");
    fprintf(myfile,"POINTS %i double\n",iVerts);

    int count=0;
    //write the actual vertex data
    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.vertices_.size();i++)
        {
          fprintf(myfile,"%f %f %f \n",pMesh.vertices_[i].x,pMesh.vertices_[i].y,pMesh.vertices_[i].z);
        }//end for
      }//for
      count++;
    }//end for

    int lengthPolyList=4*iPolys;
    fprintf(myfile,"POLYGONS %i %i \n",iPolys,lengthPolyList);
    vertsIter = vVerts.begin();
    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      int ivertsModel = *vertsIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.numFaces_;i++)
        {
          TriFace &tri = pMesh.faces_[i];
          fprintf(myfile,"3 %i %i %i \n",tri[0]+ioffset, tri[1]+ioffset, tri[2]+ioffset);
        }//end for faces
        ioffset+=pMesh.numVerts_;
      }//for submeshes
      vertsIter++;
    }//for models

    fprintf(myfile,"POINT_DATA %i \n",iVerts);
    fprintf(myfile,"SCALARS dummy double 1 \n");
    fprintf(myfile,"LOOKUP_TABLE default\n");
    int modelid=0;
    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.vertices_.size();i++)
        {
          fprintf(myfile,"%f\n",(pMesh.vertices_[0]-pMesh.vertices_[i]).mag());
        }//end for
      }//for
      modelid++;
    }//end for
    fprintf(myfile,"CELL_DATA %i \n",iPolys);
    fprintf(myfile,"SCALARS CellID int 1\n");
    fprintf(myfile,"LOOKUP_TABLE default\n");
    int cellid=0;
    for(modelIter = pModels.begin(),rIter=pRigidBodies.begin();modelIter!=pModels.end();modelIter++,rIter++)
    {
      RigidBody &body = *(*rIter);
      Model3D &pModel = *modelIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.numFaces_;i++)
        {
          fprintf(myfile,"%i \n",cellid);
        }//end for faces
      }//for submeshes
      cellid++;
    }//for models

    fprintf(myfile,"SCALARS ContactGroup int 1\n");
    fprintf(myfile,"LOOKUP_TABLE default\n");
    for(modelIter = pModels.begin(),rIter=pRigidBodies.begin();modelIter!=pModels.end();modelIter++,rIter++)
    {
      RigidBody &body = *(*rIter);
      Model3D &pModel = *modelIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.numFaces_;i++)
        {
          fprintf(myfile,"%i \n",body.group_);
        }//end for faces
      }//for submeshes
      cellid++;
    }//for models

    fprintf(myfile,"SCALARS StackHeight int 1\n");
    fprintf(myfile,"LOOKUP_TABLE default\n");
    for(modelIter = pModels.begin(),rIter=pRigidBodies.begin();modelIter!=pModels.end();modelIter++,rIter++)
    {
      RigidBody &body = *(*rIter);
      Model3D &pModel = *modelIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.numFaces_;i++)
        {
          fprintf(myfile,"%i \n",body.height_);
        }//end for faces
      }//for submeshes
      cellid++;
    }//for models	

    fclose (myfile);

  }

  void CVtkWriter::WriteRigidBodyCom(std::vector<RigidBody*> &pRigidBodies,const char *strFileName)
  {
    using namespace std;
    FILE * myfile = fopen(strFileName,"w");

    if (myfile == NULL) {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }

    int i,j;

    fprintf(myfile,"# vtk DataFile Version 2.0\n");
    fprintf(myfile,"Generated by InShape 2.x\n");
    fprintf(myfile,"ASCII\n");
    fprintf(myfile,"DATASET UNSTRUCTURED_GRID\n");

    //total number of vertices
    int iVerts=0;
    //total number of polygons
    int iPolys=0;
    //iterators for models and submeshes
    vector<Mesh3D>::iterator meshIter;
    vector<Model3D>::iterator modelIter;
    vector<RigidBody*>::iterator rIter;
    vector<Model3D> pModels;
    vector<int> vVerts;
    vector<int>::iterator vertsIter;
    int ioffset=0;

    for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
    {
      RigidBody &body = *(*rIter);
      if(body.shapeId_ != RigidBody::SPHERE && body.affectedByGravity_)
      {
        iVerts++;
      }
    }

    fprintf(myfile,"POINTS %i double\n",iVerts);

    for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
    {
      RigidBody &body = *(*rIter);
      if(body.shapeId_ != RigidBody::SPHERE && body.affectedByGravity_)
      {
        fprintf(myfile,"%f %f %f \n",body.com_.x,body.com_.y,body.com_.z);
      }
    }

    fprintf(myfile,"POINT_DATA %i\n",iVerts);
    fprintf(myfile,"SCALARS color double 1\n");
    fprintf(myfile,"LOOKUP_TABLE default\n");
    for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
    {
      RigidBody &body = *(*rIter);
      if(body.shapeId_ != RigidBody::SPHERE && body.affectedByGravity_)
      {
        fprintf(myfile,"%f\n",body.color_);
      }
    }

    fprintf(myfile,"VECTORS COM double\n");
    for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
    {
      RigidBody &body = *(*rIter);
      if(body.shapeId_ != RigidBody::SPHERE && body.affectedByGravity_)
      {
        fprintf(myfile,"%f %f %f\n",body.com_.x, body.com_.y, body.com_.z);
      }
    }

    fprintf(myfile,"VECTORS velocity double\n");
    for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
    {
      RigidBody &body = *(*rIter);
      if(body.shapeId_ != RigidBody::SPHERE && body.affectedByGravity_)
      {
        fprintf(myfile,"%f %f %f\n",body.velocity_.x, body.velocity_.y, body.velocity_.z);
      }
    }

    fclose( myfile );

  }

  void CVtkWriter::WriteBodiesAsUnstructured(std::vector<RigidBody*> &pRigidBodies,const char *strFileName)
  {

    using namespace std;
    FILE * myfile = fopen(strFileName,"w");

    if (myfile == NULL) {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }

    //total number of vertices
    int iVerts=0;
    //total number of polygons
    int iPolys=0;
    //iterators for models and submeshes
    vector<Mesh3D>::iterator meshIter;
    vector<Model3D>::iterator modelIter;
    vector<RigidBody*>::iterator rIter;
    vector<Model3D> pModels;
    vector<int> vVerts;
    vector<int>::iterator vertsIter;
    int ioffset=0;

    for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
    {
      RigidBody &body = *(*rIter);
      if(body.shapeId_ == RigidBody::BOX)
      {
        CTriangulator<Real, OBB3<Real> > triangulator;
        OBB3r *pBox = dynamic_cast<OBB3r*>(body.shape_);
        Model3D model_out=triangulator.Triangulate(*pBox);
        model_out.meshes_[0].transform_ = body.getTransformationMatrix();
        model_out.meshes_[0].com_ =body.com_;
        model_out.meshes_[0].TransformModelWorld();
        pModels.push_back(model_out);
      }
      else if(body.shapeId_ == RigidBody::SPHERE)
      {
        CTriangulator<Real, Sphere<Real> > triangulator;
        Spherer *pSphere = dynamic_cast<Spherer*>(body.shape_);
        Model3D model_out=triangulator.Triangulate(*pSphere);
        model_out.meshes_[0].transform_ =body.getTransformationMatrix();
        model_out.meshes_[0].com_ =body.com_;
        model_out.meshes_[0].TransformModelWorld();
        pModels.push_back(model_out);
      }
      else if(body.shapeId_ == RigidBody::CYLINDER)
      {
        CTriangulator<Real, Cylinder<Real> > triangulator;
        Cylinderr *pCylinder = dynamic_cast<Cylinderr*>(body.shape_);
        Model3D model_out=triangulator.Triangulate(*pCylinder);
        model_out.meshes_[0].transform_ =body.getTransformationMatrix();
        model_out.meshes_[0].com_ =body.com_;
        model_out.meshes_[0].TransformModelWorld();
        pModels.push_back(model_out);
      }
      else if(body.shapeId_ == RigidBody::MESH)
      {
        MeshObject<Real> *pMeshObject = dynamic_cast<MeshObject<Real>*>(body.shape_);
        Model3D model_out=pMeshObject->getModel();
        //actually loop over all meshes and transform them
        for(int imesh=0;imesh < model_out.meshes_.size();imesh++)
        {
          model_out.meshes_[imesh].transform_ =body.getTransformationMatrix();
          model_out.meshes_[imesh].com_ =body.com_;
          model_out.meshes_[imesh].TransformModelWorld();
        }
        pModels.push_back(model_out);

        //       //if the mesh has a bvh call the writetree level method
        //       if(pMeshObject->m_BVH.GetNumChildren()!=0)
        //       {
        //         int depth = pMeshObject->m_BVH.GetDepth();
        //         for(int level=0;level<depth;level++)
        //         {
        //           std::vector<CBoundingVolumeNode3<AABB3r,Real,CTraits> *> vec=
        //           pMeshObject->m_BVH.GetNodesLevel(level);
        // 
        //           std::ostringstream sName;
        //           std::string sModel(strFileName);
        //           sName<<".level"<<level;
        //           sModel.append(sName.str());
        //           WriteTreeLevel(vec,sModel.c_str());
        //         }
        //       }

      }
    }

    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      int ivertsModel=0;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        iVerts+=pMesh.numVerts_;
        iPolys+=pMesh.numFaces_;
        ivertsModel+=pMesh.numVerts_;
      }
      vVerts.push_back(ivertsModel);
    }

    fprintf(myfile,"# vtk DataFile Version 2.0\n");
    fprintf(myfile,"Generated by InShape 2.x\n");
    fprintf(myfile,"ASCII\n");
    fprintf(myfile,"DATASET POLYDATA\n");
    fprintf(myfile,"POINTS %i double\n",iVerts);

    //write the actual vertex data
    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.vertices_.size();i++)
        {
          fprintf(myfile,"%f %f %f \n",pMesh.vertices_[i].x,pMesh.vertices_[i].y,pMesh.vertices_[i].z);
        }//end for
      }//for
    }//end for

    int lengthPolyList=4*iPolys;
    fprintf(myfile,"POLYGONS %i %i \n",iPolys,lengthPolyList);
    vertsIter = vVerts.begin();
    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      int ivertsModel = *vertsIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.numFaces_;i++)
        {
          fprintf(myfile,"3 %i %i %i \n",pMesh.faces_[i][0]+ioffset, pMesh.faces_[i][1]+ioffset, pMesh.faces_[i][2]+ioffset);
        }//end for faces
        ioffset+=pMesh.numVerts_;
      }//for submeshes
      vertsIter++;
    }//for models

    fprintf(myfile,"POINT_DATA %i \n",iVerts);
    fprintf(myfile,"SCALARS dummy double 1 \n");
    fprintf(myfile,"LOOKUP_TABLE default\n");
    int modelid=0;
    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.vertices_.size();i++)
        {
          fprintf(myfile,"%f\n",(pMesh.vertices_[0]-pMesh.vertices_[i]).mag());
        }//end for
      }//for
      modelid++;
    }//end for
    fprintf(myfile,"CELL_DATA %i \n",iPolys);
    fprintf(myfile,"SCALARS CellID int 1\n");
    fprintf(myfile,"LOOKUP_TABLE default\n");
    int cellid=0;
    for(modelIter = pModels.begin(),rIter=pRigidBodies.begin();modelIter!=pModels.end();modelIter++,rIter++)
    {
      RigidBody &body = *(*rIter);
      Model3D &pModel = *modelIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.numFaces_;i++)
        {
          fprintf(myfile,"%i \n",cellid);
        }//end for faces
      }//for submeshes
      cellid++;
    }//for models

    fprintf(myfile,"SCALARS ContactGroup int 1\n");
    fprintf(myfile,"LOOKUP_TABLE default\n");
    for(modelIter = pModels.begin(),rIter=pRigidBodies.begin();modelIter!=pModels.end();modelIter++,rIter++)
    {
      RigidBody &body = *(*rIter);
      Model3D &pModel = *modelIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.numFaces_;i++)
        {
          fprintf(myfile,"%i \n",body.group_);
        }//end for faces
      }//for submeshes
      cellid++;
    }//for models

    fprintf(myfile,"SCALARS StackHeight int 1\n");
    fprintf(myfile,"LOOKUP_TABLE default\n");
    for(modelIter = pModels.begin(),rIter=pRigidBodies.begin();modelIter!=pModels.end();modelIter++,rIter++)
    {
      RigidBody &body = *(*rIter);
      Model3D &pModel = *modelIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.numFaces_;i++)
        {
          fprintf(myfile,"%i \n",body.height_);
        }//end for faces
      }//for submeshes
      cellid++;
    }//for models 

    fclose (myfile);

  }

  void CVtkWriter::WriteModels(std::vector<Model3D> &pModels,const char *strFileName)
  {
    using namespace std;

    FILE * myfile = fopen(strFileName,"w");

    if (myfile == NULL) {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }

    //total number of vertices
    int iVerts=0;
    //total number of polygons
    int iPolys=0;
    //iterators for models and submeshes
    vector<Mesh3D>::iterator meshIter;
    vector<Model3D>::iterator modelIter;
    vector<int> vVerts;
    vector<int>::iterator vertsIter;
    int ioffset=0;

    //write the vertices of all models
    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      int ivertsModel=0;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        iVerts+=pMesh.numVerts_;
        iPolys+=pMesh.numFaces_;
        ivertsModel+=pMesh.numVerts_;
      }
      vVerts.push_back(ivertsModel);
    }

    fprintf(myfile,"# vtk DataFile Version 2.0\n");
    fprintf(myfile,"Generated by InShape 2.x\n");
    fprintf(myfile,"ASCII\n");
    fprintf(myfile,"DATASET POLYDATA\n");
    fprintf(myfile,"POINTS %i double\n",iVerts);

    //write the actual vertex data
    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.vertices_.size();i++)
        {
          fprintf(myfile,"%f %f %f \n",pMesh.vertices_[i].x,pMesh.vertices_[i].y,pMesh.vertices_[i].z);
        }//end for
      }//for
    }//end for

    int lengthPolyList=4*iPolys;
    fprintf(myfile,"POLYGONS %i %i \n",iPolys,lengthPolyList);
    vertsIter = vVerts.begin();
    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      int ivertsModel = *vertsIter;
      int subMeshOffset = 0;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.numFaces_;i++)
        {
          fprintf(myfile,"3 %i %i %i \n",pMesh.faces_[i][0]+ioffset+subMeshOffset, pMesh.faces_[i][1]+ioffset+subMeshOffset, pMesh.faces_[i][2]+ioffset+subMeshOffset);
        }//end for faces
        subMeshOffset+=pMesh.getNumVerts();
      }//for submeshes
      ioffset+=ivertsModel;
      vertsIter++;
    }//for models

    fprintf(myfile,"CELL_DATA %i \n",iPolys);
    fprintf(myfile,"SCALARS CellID int 1\n");
    fprintf(myfile,"LOOKUP_TABLE default\n");

    int iModel=0;
    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        //cout<<"Collision state: "<<body.m_iCollisionState<<endl;
        for(int i=0;i<pMesh.numFaces_;i++)
        {
          fprintf(myfile,"%i \n",iModel);
        }//end for faces
      }//for submeshes
      iModel++;
    }//for models	

    fclose (myfile);

  }//end function

  void CVtkWriter::writePostScriptTree(CBoundingVolumeTree3<AABB3r,Real,CTraits,CSubdivisionCreator> &bvh, const char *strFileName)
  {

    using namespace std;
    ofstream myfile(strFileName);

    //check
    if(!myfile.is_open())
    {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }//end if

    float scale = 0.5;
    cout << "depth: " << bvh.GetDepth() << endl;
    int depth = bvh.GetDepth()+1;
    float rad = 20.0f;
    float space = 5.0f;
    float y = space + depth * rad;

    float stride_x = scale * 2. * (rad + space);
    float stride_y = scale * 2. * (rad + space);
    float pos_top = depth * 2. * rad + space;

    int leaves = 4;
    float posx_root = 0.5f * leaves * stride_x;


    //if the mesh has a bvh call the writetree level method
    if(bvh.GetNumChildren()!=0)
    {

      float start_level = 0.5 * stride_x;
      float start_y = 0.5 * stride_y;

      float stride_level = stride_x;
      int count = 0;
      for(int level=depth;level!=0;level--)
      {
        start_level = pow(2,count) * 0.5 * stride_x;
        //std::vector<CBoundingVolumeNode3<AABB3r,Real,CTraits> *> vec=
        //bvh.GetNodesLevel(level);

        //cout << "posy: " << start_y << endl;
        std::vector<CBoundingVolumeNode3<AABB3r,Real,CTraits> *> vec=
          bvh.GetNodesLevel(level-1);

        for(int j=0; j < vec.size();j++)
        {
          myfile << "newpath"<<endl;
          myfile << start_level + j * stride_x * pow(2.0,count);
          myfile << " " << start_y;
          myfile << " " << scale * rad;
          myfile << " 0 360 arc" << endl;
          myfile << "stroke"<<endl;
        }

        start_y += stride_y;
        count++;

      }
    }
    myfile << "showpage"<<endl;

    //close the file
    myfile.close();

  }

  void CVtkWriter::WriteTreeLevel(std::vector<CBoundingVolumeNode3<AABB3r,Real,CTraits> *> &vec, const char *strFileName)
  {

    using namespace std;
    ofstream myfile(strFileName);

    //check
    if(!myfile.is_open())
    {
      cout<<"Error opening file: "<<"output.vtk"<<endl;
      exit(0);
    }//end if

    int NVE=8;
    int iPoints= (int)vec.size()*NVE;
    int iCells = (int)vec.size();
    myfile<<"# vtk DataFile Version 2.0"<<endl;
    myfile<<"Generated by InShape 2.x"<<endl;
    myfile<<"ASCII"<<endl;
    myfile<<"DATASET UNSTRUCTURED_GRID"<<endl;
    myfile<<"POINTS "<<iPoints<<" double"<<endl;
    myfile.precision(7);

    vector<CBoundingVolumeNode3<AABB3r,Real,CTraits> *>::iterator vIter;

    for(vIter=vec.begin();vIter!=vec.end();vIter++)
    {
      CBoundingVolumeNode3<AABB3r,Real,CTraits> *pNode=*vIter;
      AABB3r &rBox=pNode->m_BV;
      for(int j=0;j<8;j++)
      {
        myfile<<rBox.getVertex(j).x<<" "<<rBox.getVertex(j).y<<" "<<rBox.getVertex(j).z<<endl;
      }
    }//end for

    myfile.precision();
    myfile<<"CELLS "<<iCells<<" "<<iCells*9<<endl;
    for(int i=0;i<(int)vec.size();i++)
    {
      myfile <<8<<" ";
      for(int j=0;j<8;j++)
        myfile<<(i*8)+j<<" ";
      myfile<<endl;
    }//end for

    myfile<<"CELL_TYPES "<<iCells<<endl;
    for(int i=0;i<iCells;i++)
    {
      myfile<<12<<endl;
    }//end for

    myfile<<"CELL_DATA "<<iCells<<endl;
    myfile<<"SCALARS "<<"Collision int 1"<<endl;
    myfile<<"LOOKUP_TABLE default"<<endl;
    for(int i=0;i<iCells;i++)
    {
      myfile<<vec[i]->m_Traits.iCollision<<endl;
    }//end for  

    //close the file
    myfile.close();
  }

  void CVtkWriter::WritePoints(std::vector<VECTOR3> &points,const char *strFileName)
  {
    using namespace std;
    FILE * myfile = fopen(strFileName,"w");

    if (myfile == NULL) {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }

    int i,j;

    fprintf(myfile,"# vtk DataFile Version 2.0\n");
    fprintf(myfile,"Generated by InShape 2.x\n");
    fprintf(myfile,"ASCII\n");
    fprintf(myfile,"DATASET UNSTRUCTURED_GRID\n");

    //total number of vertices
    int iVerts=points.size();
    //total number of polygons
    int iPolys=0;
    //iterators for models and submeshes
    vector<VECTOR3>::iterator vIter;

    fprintf(myfile,"POINTS %i double\n",iVerts);  

    for(vIter=points.begin();vIter!=points.end();vIter++)
    {
      VECTOR3 &vec = *vIter;
      fprintf(myfile,"%f %f %f \n",vec.x,vec.y,vec.z);      
    }

    fclose( myfile );

  }

  void CVtkWriter::WriteTryp(std::vector<VECTOR3> &points,const char *strFileName)
  {
    using namespace std;
    FILE * myfile = fopen(strFileName,"w");

    if (myfile == NULL) {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }

    int i,j;

    fprintf(myfile,"# vtk DataFile Version 2.0\n");
    fprintf(myfile,"Generated by InShape 2.x\n");
    fprintf(myfile,"ASCII\n");
    fprintf(myfile,"DATASET UNSTRUCTURED_GRID\n");

    //total number of vertices
    int iVerts=points.size();
    //total number of polygons
    int iPolys=0;
    //iterators for models and submeshes
    vector<VECTOR3>::iterator vIter;

    fprintf(myfile,"POINTS %i double\n",iVerts);  

    for(vIter=points.begin();vIter!=points.end();vIter++)
    {
      VECTOR3 &vec = *vIter;
      fprintf(myfile,"%f %f %f \n",vec.x,vec.y,vec.z);      
    }

    
    int cells = 10 * 22;

    fprintf(myfile,"CELLS %i %i\n",cells,cells*5);
    for(int section(0); section < 22; ++section)
    {
      int offset = section * 10;
      for(int j(0); j < 9; ++j)
      {
        
        int i = offset + j + 1;
        fprintf(myfile,"4  %i %i %i %i \n",i, i+10, i+9, i-1);    
      }
      fprintf(myfile,"4  %i %i %i %i \n",(section*10)+9,
                                         (section*10)+9+10,
                                         (section+1) * 10,
                                         (section) * 10);    
    }

    fprintf(myfile,"CELL_TYPES %i\n",cells);        
    for(i=0;i<cells;i++)
    {
      fprintf(myfile,"9\n");          
    }//end for

    fclose( myfile );

  }

  void CVtkWriter::WriteTriangles(std::vector<Triangle3<Real> > &pTriangles,const char *strFileName)
  {
    using namespace std;

    FILE * myfile = fopen(strFileName,"w");

    if (myfile == NULL) {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }

    //total number of vertices
    int iVerts=pTriangles.size()*3;
    //total number of polygons
    int iPolys=pTriangles.size();

    fprintf(myfile,"# vtk DataFile Version 2.0\n");
    fprintf(myfile,"Generated by InShape 2.x\n");
    fprintf(myfile,"ASCII\n");
    fprintf(myfile,"DATASET POLYDATA\n");
    fprintf(myfile,"POINTS %i double\n",iVerts);

    //write the actual vertex data
    for(int k=0;k<iPolys;k++)
    {
      VECTOR3 tri[3];
      tri[0]=pTriangles[k].m_vV0;
      tri[1]=pTriangles[k].m_vV1;
      tri[2]=pTriangles[k].m_vV2;
      for(int i=0;i<3;i++)
      {
        fprintf(myfile,"%f %f %f \n",tri[i].x,tri[i].y,tri[i].z);
      }//end for
    }//end for

    int lengthPolyList=4*iPolys;
    fprintf(myfile,"POLYGONS %i %i \n",iPolys,lengthPolyList);
    for(int i=0;i<pTriangles.size();i++)
    {
      fprintf(myfile,"3 %i %i %i \n",i*3,i*3+1,i*3+2);
    }//end for faces

    fclose (myfile);

  }//end function


  void CVtkWriter::WriteModels(std::vector<Model3D> &pModels,std::list<CollisionInfo> &vCollInfo,
      std::vector<VECTOR3> &vVel,std::list<Response> &Responses,const char *strFileName)
  {
    using namespace std;
    ofstream myfile(strFileName);
    //total number of vertices
    int iVerts=0;
    //total number of polygons
    int iPolys=0;
    //iterators for models and submeshes
    vector<Mesh3D>::iterator meshIter;
    vector<Model3D>::iterator modelIter;
    vector<int> vVerts;
    vector<int> vOffset;
    vector<int>::iterator vertsIter;
    int ioffset=0;

    //check
    if(!myfile.is_open())
    {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }//end if


    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      int ivertsModel=0;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        iVerts+=pMesh.numVerts_;
        iPolys+=pMesh.numFaces_;
        ivertsModel+=pMesh.numVerts_;
      }
      //offset to the models vertices
      vOffset.push_back(ioffset);
      ioffset+=ivertsModel;
      //total vertices of the model
      vVerts.push_back(ivertsModel);
    }

    myfile<<"# vtk DataFile Version 2.0"<<endl;
    myfile<<"Generated by InShape 2.x"<<endl;
    myfile<<"ASCII"<<endl;
    myfile<<"DATASET POLYDATA"<<endl;
    myfile<<"POINTS "<<iVerts<<" double"<<endl;
    myfile.precision(7);
    //write the actual vertex data
    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.vertices_.size();i++)
        {
          myfile<<pMesh.vertices_[i].x<<" "<<pMesh.vertices_[i].y<<" "<<pMesh.vertices_[i].z<<endl;
        }//end for
      }//for
    }//end for

    int lengthPolyList=4*iPolys;
    myfile<<"POLYGONS "<<iPolys<<" "<<lengthPolyList<<endl;
    vertsIter = vVerts.begin();
    ioffset=0;
    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      int ivertsModel = *vertsIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.numFaces_;i++)
        {
          myfile<<3<<" "<<pMesh.faces_[i][0]+ioffset<<" "
            <<pMesh.faces_[i][1]+ioffset<<" "<<pMesh.faces_[i][2]+ioffset<<endl;
        }//end for faces
      }//for submeshes
      ioffset+=ivertsModel;
      vertsIter++;
    }//for models
    myfile<<"POINT_DATA "<<iVerts<<endl;
    //myfile<<"SCALARS distance double"<<endl;
    //myfile<<"LOOKUP_TABLE default"<<endl;
    //for(int i=0;i<vVerts.size();i++)
    //{
    //	for(int j=0;j<vVerts[i];j++)
    //		myfile<<vCollInfo.front().m_dDistance<<endl;
    //}

    myfile<<"VECTORS velocity double"<<endl;
    //myfile<<"LOOKUP_TABLE default"<<endl;
    for(int i=0;i<vVerts.size();i++)
    {
      for(int j=0;j<vVerts[i];j++)
        myfile<<vVel[i].x<<" "<<vVel[i].y<<" "<<vVel[i].z<<endl;
    }

    // 	myfile<<"VECTORS FCollParticle double"<<endl;
    // 	list<CResponse>::iterator lIter;
    // 	for(lIter=Responses.begin();lIter!=Responses.end();lIter++)
    // 	{
    // 		CResponse res= *lIter;
    // 		for(int j=0;j<vVerts[0];j++)
    // 		{
    // 			myfile<<res.m_vFW1.x<<" "<<res.m_vFW1.y<<" "<<res.m_vFW1.z<<endl;
    // 		}
    // 		for(int j=0;j<vVerts[1];j++)
    // 		{
    // 			myfile<<res.m_vFW2.x<<" "<<res.m_vFW2.y<<" "<<res.m_vFW2.z<<endl;
    // 		}
    // 	}

  }//end function


  void CVtkWriter::WritePVTU(int iSubNodes, int iTimestep)
  {
    using namespace std;
    int iRangeMin,iRangeMax;
    double dRangeMin,dRangeMax;
    std::ostringstream sNameMain;
    sNameMain<<"_gmv/main."<<std::setfill('0')<<std::setw(4)<<iTimestep<<".pvtu";
    string strFileName(sNameMain.str());

    vector<string> vNames;
    string strEnding(".vtu");
    for(int i=1;i<=iSubNodes;i++)
    {

      //build the string for the current node
      std::ostringstream sName;
      sName<<"node_"<<std::setfill('0')<<std::setw(2)<<i<<"."<<std::setfill('0')<<std::setw(4)<<iTimestep;

      string strName("res_");
      strName.append(sName.str());
      strName.append(strEnding);
      vNames.push_back(strName);
    }

    //open file for writing
    FILE * myfile = fopen(strFileName.c_str(),"w");

    //Write the vtk header
    fprintf(myfile,"<VTKFile type=\"PUnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">\n");
    fprintf(myfile,"  <PUnstructuredGrid GhostLevel=\"0\">\n");

    fprintf(myfile,"    <PPointData Scalars=\"FBM\">\n");
    fprintf(myfile,"      <PDataArray type=\"Float32\" Name=\"FBM\"/>\n");
    //  myfile<<"      <PDataArray type=\"double32\" Name=\"Pressure\"/>"<<endl;
    fprintf(myfile,"      <PDataArray type=\"Float32\" Name=\"velocity\" NumberOfComponents=\"3\"/>\n");
    fprintf(myfile,"    </PPointData>\n");
    fprintf(myfile,"    <PPoints>\n");
    fprintf(myfile,"      <PDataArray type=\"Float32\" Name=\"Points\" NumberOfComponents=\"3\"/>\n");
    fprintf(myfile,"    </PPoints>\n");
    for(int i=0;i<iSubNodes;i++)
    {
      fprintf(myfile,"      <Piece Source=\"%s\"/>\n",vNames[i].c_str());
    }

    //add the finish tags
    fprintf(myfile,"  </PUnstructuredGrid>\n");
    fprintf(myfile,"</VTKFile>\n");

    //close the stream
    fclose( myfile );

  }

  void CVtkWriter::WritePUXML(int iNEL,int iNVT,int iKVERT[][8],double dcorvg[][3],double vu[],double vv[],double vw[],double vp[],double dist[],int inode, int iTimestep)
  {

    using namespace std;
    int iRangeMin,iRangeMax;
    double dRangeMin,dRangeMax;

    std::ostringstream sName;
    sName<<"node_"<<std::setfill('0')<<std::setw(2)<<inode<<"."<<std::setfill('0')<<std::setw(4)<<iTimestep;

    string strEnding(".vtu");
    string strFileName("_gmv/res_");
    strFileName.append(sName.str());
    strFileName.append(strEnding);

    //open file for writing
    FILE * myfile = fopen(strFileName.c_str(),"w");

    //check
    fprintf(myfile,"<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">\n");

    //Write the vtk header
    fprintf(myfile,"  <UnstructuredGrid>\n");

    //Next item is the number of points and cells
    fprintf(myfile,"    <Piece NumberOfPoints=\"%i\" NumberOfCells=\"%i\">\n",iNVT,iNEL);

    //write the pointdata distance scalar
    fprintf(myfile,"      <PointData Scalars=\"FBM\">\n");

    fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"FBM\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"1.0\">\n");
    for(int i=0;i<iNVT;i++)
    {
      fprintf(myfile,"          %f\n",dist[i]);
    }//end for

    fprintf(myfile,"        </DataArray>\n");

    //   //write the pointdata distance scalar
    //   fprintf(myfile,"        <DataArray type=\"double32\" Name=\"Pressure\" format=\"ascii\">\n");
    //   for(int i=0;i<iNVT;i++)
    //   {
    //   fprintf(myfile,"          %f \n",vp[i]);
    //   }//end for
    //   fprintf(myfile,"        </DataArray>\n");



    //before we write the velocity, we have to calculate the minimum and maximum
    //before we write the velocity, we have to calculate the minimum and maximum
    if(vu[0]<=vv[0])
    {
      if(vu[0]<=vw[0])
      {
        dRangeMin=vu[0];
      }
      else
      {
        dRangeMin=vw[0];
      }
    }
    else
    {
      if(vv[0]<=vw[0])
      {
        dRangeMin=vv[0];
      }
      else
      {
        dRangeMin=vw[0];
      }
    }

    if(vu[0]>=vv[0])
    {
      if(vu[0]>=vw[0])
      {
        dRangeMax=vu[0];
      }
      else
      {
        dRangeMax=vw[0];
      }
    }
    else
    {
      if(vv[0]>=vw[0])
      {
        dRangeMax=vv[0];
      }
      else
      {
        dRangeMax=vw[0];
      }		
    }	

    for(int i=1;i<iNVT;i++)
    {
      if(vu[i]<dRangeMin)
        dRangeMin=vu[i];
      if(vv[i]<dRangeMin)
        dRangeMin=vv[i];
      if(vw[i]<dRangeMin)
        dRangeMin=vw[i];

      if(vu[i]>dRangeMax)
        dRangeMax=vu[i];
      if(vv[i]>dRangeMax)
        dRangeMax=vv[i];
      if(vw[i]>dRangeMax)
        dRangeMax=vw[i];

    }

    //write the pointdata velocity array
    //  fprintf(myfile,"      <PointData Vectors=\"velocity\">\n");
    fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"velocity\" NumberOfComponents=\"3\" format=\"ascii\" RangeMin=\"%f\" RangeMax=\"%f\">\n", dRangeMin,dRangeMax);
    for(int i=0;i<iNVT;i++)
    {
      fprintf(myfile,"          %f %f %f\n",vu[i],vv[i],vw[i]);
    }//end for

    fprintf(myfile,"        </DataArray>\n");
    fprintf(myfile,"      </PointData>\n");

    //write the points data array to the file
    fprintf(myfile,"      <Points>\n");
    fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"Points\" NumberOfComponents=\"3\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"1.0\">\n");
    for(int i=0;i<iNVT;i++)
    {
      fprintf(myfile,"          %f %f %f\n",dcorvg[i][0],dcorvg[i][1],dcorvg[i][2]);
    }//end for

    fprintf(myfile,"        </DataArray>\n");
    fprintf(myfile,"      </Points>\n");

    //Next item is the cell data array
    fprintf(myfile,"      <Cells>\n");
    fprintf(myfile,"        <DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"%i\">\n",iNEL-1);
    fprintf(myfile,"          ");
    for(int i=0;i<iNEL;i++)
    {
      fprintf(myfile,"          %i %i %i %i %i %i %i %i\n",iKVERT[i][0]-1,iKVERT[i][1]-1,iKVERT[i][2]-1,iKVERT[i][3]-1,iKVERT[i][4]-1,iKVERT[i][5]-1,iKVERT[i][6]-1,iKVERT[i][7]-1);
    }

    fprintf(myfile,"</DataArray>\n");

    //the offset seems to be mandatory
    fprintf(myfile,"        <DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\" RangeMin=\"8\" RangeMax=\"%i\">\n",iNEL*8);
    fprintf(myfile,"          ");
    for(int i=1;i<=iNEL;i++)
    {
      fprintf(myfile,"%i ",i*8);
      if(i%6==0)
      {
        fprintf(myfile,"\n");
        fprintf(myfile,"          ");
      }
    }

    if(iNEL%6!=0)fprintf(myfile,"\n");
    fprintf(myfile,"        </DataArray>\n");

    //add a data array with the types of the cells
    fprintf(myfile,"        <DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\" RangeMin=\"12\" RangeMax=\"12\">\n");
    fprintf(myfile,"          ");
    for(int i=1;i<=iNEL;i++)
    {
      fprintf(myfile,"12 ");
      if(i%6==0)
      {
        fprintf(myfile,"\n");
        fprintf(myfile,"          ");
      }
    }

    if(iNEL%6!=0)	fprintf(myfile,"\n");
    fprintf(myfile,"        </DataArray>\n");

    //finish the cells and the piece
    fprintf(myfile,"      </Cells>\n");
    fprintf(myfile,"    </Piece>\n");

    //add the finish tags
    fprintf(myfile,"  </UnstructuredGrid>\n");
    fprintf(myfile,"</VTKFile>\n");

    fclose( myfile );

  }

  void CVtkWriter::WriteGrid2Tri(CUnstrGrid &Grid, const char *strFileName)
  {
    using namespace std;

    //open file for writing
    FILE * myfile = fopen(strFileName,"w");

    fprintf(myfile,"Coarse mesh exported by KaBooM \n");
    fprintf(myfile,"Version 0.1a \n");

    fprintf(myfile,"    %i %i 0 8 12 6     NEL,NVT,NBCT,NVE,NEE,NAE\n",Grid.nel_,Grid.nvt_); 

    fprintf(myfile,"DCORVG\n");  
    //write the points data array to the file
    for(int i=0;i<Grid.nvt_;i++)
    {
      fprintf(myfile,"%f %f %f\n",Grid.vertexCoords_[i].x,Grid.vertexCoords_[i].y,Grid.vertexCoords_[i].z);
    }//end for

    fprintf(myfile,"KVERT\n");
    for(int i=0;i<Grid.nel_;i++)
    {
      fprintf(myfile,"%i %i %i %i %i %i %i %i\n",Grid.hexas_[i].hexaVertexIndices_[0]+1,Grid.hexas_[i].hexaVertexIndices_[1]+1,Grid.hexas_[i].hexaVertexIndices_[2]+1,Grid.hexas_[i].hexaVertexIndices_[3]+1,
          Grid.hexas_[i].hexaVertexIndices_[4]+1,Grid.hexas_[i].hexaVertexIndices_[5]+1,Grid.hexas_[i].hexaVertexIndices_[6]+1,Grid.hexas_[i].hexaVertexIndices_[7]+1);
    }   

    fprintf(myfile,"KNPR\n");
    for(int i=0;i<Grid.nvt_;i++)
    {
      fprintf(myfile,"%i\n",Grid.verticesAtBoundary_[i]);
    }

    fclose( myfile );  

  }

  void CVtkWriter::WriteTriFile(int NEL, int NVT, int iKVERT[][8], double dcorvg[][3],int id)
  {
    using namespace std;
    std::ostringstream sName;
    sName<<"grid_"<<std::setfill('0')<<std::setw(2)<<id;

    string strEnding(".tri");
    string strFileName("_gmv/");
    strFileName.append(sName.str());
    strFileName.append(strEnding);

    //open file for writing
    FILE * myfile = fopen(strFileName.c_str(),"w");

    fprintf(myfile,"Coarse mesh exported by KaBooM \n");
    fprintf(myfile,"Version 0.1a \n");

    fprintf(myfile,"    %i %i 0 8 12 6     NEL,NVT,NBCT,NVE,NEE,NAE\n",NEL,NVT); 

    fprintf(myfile,"DCORVG\n");  
    //write the points data array to the file
    for(int i=0;i<NVT;i++)
    {
      fprintf(myfile,"%f %f %f\n",dcorvg[i][0],dcorvg[i][1],dcorvg[i][2]);
    }//end for

    fprintf(myfile,"KVERT\n");
    for(int i=0;i<NEL;i++)
    {
      fprintf(myfile,"%i %i %i %i %i %i %i %i\n",iKVERT[i][0],iKVERT[i][1],iKVERT[i][2],iKVERT[i][3],iKVERT[i][4],iKVERT[i][5],iKVERT[i][6],iKVERT[i][7]);
    }

    fprintf(myfile,"KNPR\n");
    for(int i=0;i<NVT;i++)
    {
      fprintf(myfile,"0\n");
    }

    fclose( myfile );  
  }

  void CVtkWriter::WriteVTK22(int *NEL,int *NVT,int iKVERT[][8],double dcorvg[][3],double dmon1[],double dmon2[],double df[],double du[],double dgradx[],double dgrady[],double dgradz[],double *dt, double *ddt,int ivl, int imst, int itst,int ismst)
  {

    using namespace std;
    int iRangeMin,iRangeMax;
    double dRangeMin,dRangeMax;
    int iNEL = *NEL;
    int iNVT = *NVT;  
    std::ostringstream sName;
    int inode = 0;
    int iTimestep = 0;
    sName<<"SOL."<<std::setfill('0')<<std::setw(2)<<ivl<<"."<<std::setfill('0')<<std::setw(3)<<imst<<"."<<std::setfill('0')<<std::setw(3)<<itst<<"."<<std::setfill('0')<<std::setw(4)<<ismst;

    string strEnding(".vtu");
    string strFileName("_gmv/");
    strFileName.append(sName.str());
    strFileName.append(strEnding);

    //open file for writing
    FILE * myfile = fopen(strFileName.c_str(),"w");

    //check
    fprintf(myfile,"<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">\n");

    //Write the vtk header
    fprintf(myfile,"  <UnstructuredGrid>\n");

    //Next item is the number of points and cells
    fprintf(myfile,"    <Piece NumberOfPoints=\"%i\" NumberOfCells=\"%i\">\n",iNVT,iNEL);

    //write the pointdata distance scalar
    fprintf(myfile,"      <PointData Scalars=\"MonitorOld\">\n");

    fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"MonitorOld\" format=\"ascii\">\n");
    for(int i=0;i<iNVT;i++)
    {
      fprintf(myfile,"          %f\n",dmon1[i]);
    }//end for

    fprintf(myfile,"        </DataArray>\n");

    fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"MonitorNew\" format=\"ascii\">\n");
    for(int i=0;i<iNVT;i++)
    {
      fprintf(myfile,"          %f\n",dmon2[i]);
    }//end for

    fprintf(myfile,"        </DataArray>\n");

    fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"DF\" format=\"ascii\">\n");
    for(int i=0;i<iNVT;i++)
    {
      fprintf(myfile,"          %f\n",df[i]);
    }//end for

    fprintf(myfile,"        </DataArray>\n");

    fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"DU\" format=\"ascii\">\n");
    for(int i=0;i<iNVT;i++)
    {
      fprintf(myfile,"          %f\n",du[i]);
    }//end for

    fprintf(myfile,"        </DataArray>\n");

    //write the pointdata velocity array
    fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"gradient\" NumberOfComponents=\"3\" format=\"ascii\">\n");
    for(int i=0;i<iNVT;i++)
    {
      fprintf(myfile,"          %f %f %f\n",dgradx[i],dgrady[i],dgradz[i]);
    }//end for

    fprintf(myfile,"        </DataArray>\n");
    fprintf(myfile,"      </PointData>\n");

    //write the points data array to the file
    fprintf(myfile,"      <Points>\n");
    fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"Points\" NumberOfComponents=\"3\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"1.0\">\n");
    for(int i=0;i<iNVT;i++)
    {
      fprintf(myfile,"          %f %f %f\n",dcorvg[i][0],dcorvg[i][1],dcorvg[i][2]);
    }//end for

    fprintf(myfile,"        </DataArray>\n");
    fprintf(myfile,"      </Points>\n");

    //Next item is the cell data array
    fprintf(myfile,"      <Cells>\n");
    fprintf(myfile,"        <DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"%i\">\n",iNEL-1);
    fprintf(myfile,"          ");
    for(int i=0;i<iNEL;i++)
    {
      fprintf(myfile,"          %i %i %i %i %i %i %i %i\n",iKVERT[i][0]-1,iKVERT[i][1]-1,iKVERT[i][2]-1,iKVERT[i][3]-1,iKVERT[i][4]-1,iKVERT[i][5]-1,iKVERT[i][6]-1,iKVERT[i][7]-1);
    }

    fprintf(myfile,"</DataArray>\n");

    //the offset seems to be mandatory
    fprintf(myfile,"        <DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\" RangeMin=\"8\" RangeMax=\"%i\">\n",iNEL*8);
    fprintf(myfile,"          ");
    for(int i=1;i<=iNEL;i++)
    {
      fprintf(myfile,"%i ",i*8);
      if(i%6==0)
      {
        fprintf(myfile,"\n");
        fprintf(myfile,"          ");
      }
    }

    if(iNEL%6!=0)fprintf(myfile,"\n");
    fprintf(myfile,"        </DataArray>\n");

    //add a data array with the types of the cells
    fprintf(myfile,"        <DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\" RangeMin=\"12\" RangeMax=\"12\">\n");
    fprintf(myfile,"          ");
    for(int i=1;i<=iNEL;i++)
    {
      fprintf(myfile,"12 ");
      if(i%6==0)
      {
        fprintf(myfile,"\n");
        fprintf(myfile,"          ");
      }
    }

    if(iNEL%6!=0)	fprintf(myfile,"\n");
    fprintf(myfile,"        </DataArray>\n");

    //finish the cells and the piece
    fprintf(myfile,"      </Cells>\n");
    fprintf(myfile,"    </Piece>\n");

    //add the finish tags
    fprintf(myfile,"  </UnstructuredGrid>\n");
    fprintf(myfile,"</VTKFile>\n");

    fclose( myfile );

    WriteTriFile(iNEL,iNVT,iKVERT,dcorvg,imst);

  }

  void CVtkWriter::WriteVTK23(int *NEL,int *NVT, int iKVERT[][8],double dcorvg[][3],
      double dmon[],double dsize[],double dratio[],double *DT,double *DDT,int ivl,int imst,int itst,int ismst)
  {

    using namespace std;
    int iRangeMin,iRangeMax;
    double dRangeMin,dRangeMax;
    int iNEL = *NEL;
    int iNVT = *NVT;  
    std::ostringstream sName;
    int inode = 0;
    int iTimestep = 0;
    sName<<"MACRO."<<std::setfill('0')<<std::setw(2)<<ivl<<"."<<std::setfill('0')<<std::setw(3)<<imst<<"."<<std::setfill('0')<<std::setw(3)<<itst<<"."<<std::setfill('0')<<std::setw(4)<<ismst;

    string strEnding(".vtu");
    string strFileName("_gmv/");
    strFileName.append(sName.str());
    strFileName.append(strEnding);

    //open file for writing
    FILE * myfile = fopen(strFileName.c_str(),"w");

    //check
    fprintf(myfile,"<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">\n");

    //Write the vtk header
    fprintf(myfile,"  <UnstructuredGrid>\n");

    //Next item is the number of points and cells
    fprintf(myfile,"    <Piece NumberOfPoints=\"%i\" NumberOfCells=\"%i\">\n",iNVT,iNEL);

    //write the pointdata distance scalar
    fprintf(myfile,"      <PointData Scalars=\"MonitorOld\">\n");

    fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"SmoothedMonitor\" format=\"ascii\">\n");
    for(int i=0;i<iNVT;i++)
    {
      fprintf(myfile,"          %f\n",dmon[i]);
    }//end for

    fprintf(myfile,"        </DataArray>\n");  

    fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"Size\" format=\"ascii\">\n");
    for(int i=0;i<iNVT;i++)
    {
      fprintf(myfile,"          %f\n",dsize[i]);
    }//end for

    fprintf(myfile,"        </DataArray>\n");

    fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"Ratio\" format=\"ascii\">\n");
    for(int i=0;i<iNVT;i++)
    {
      fprintf(myfile,"          %f\n",dratio[i]);
    }//end for

    fprintf(myfile,"        </DataArray>\n");

    fprintf(myfile,"      </PointData>\n");

    //write the points data array to the file
    fprintf(myfile,"      <Points>\n");
    fprintf(myfile,"        <DataArray type=\"Float32\" Name=\"Points\" NumberOfComponents=\"3\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"1.0\">\n");
    for(int i=0;i<iNVT;i++)
    {
      fprintf(myfile,"          %f %f %f\n",dcorvg[i][0],dcorvg[i][1],dcorvg[i][2]);
    }//end for

    fprintf(myfile,"        </DataArray>\n");
    fprintf(myfile,"      </Points>\n");

    //Next item is the cell data array
    fprintf(myfile,"      <Cells>\n");
    fprintf(myfile,"        <DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"%i\">\n",iNEL-1);
    fprintf(myfile,"          ");
    for(int i=0;i<iNEL;i++)
    {
      fprintf(myfile,"          %i %i %i %i %i %i %i %i\n",iKVERT[i][0]-1,iKVERT[i][1]-1,iKVERT[i][2]-1,iKVERT[i][3]-1,iKVERT[i][4]-1,iKVERT[i][5]-1,iKVERT[i][6]-1,iKVERT[i][7]-1);
    }

    fprintf(myfile,"</DataArray>\n");

    //the offset seems to be mandatory
    fprintf(myfile,"        <DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\" RangeMin=\"8\" RangeMax=\"%i\">\n",iNEL*8);
    fprintf(myfile,"          ");
    for(int i=1;i<=iNEL;i++)
    {
      fprintf(myfile,"%i ",i*8);
      if(i%6==0)
      {
        fprintf(myfile,"\n");
        fprintf(myfile,"          ");
      }
    }

    if(iNEL%6!=0)fprintf(myfile,"\n");
    fprintf(myfile,"        </DataArray>\n");

    //add a data array with the types of the cells
    fprintf(myfile,"        <DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\" RangeMin=\"12\" RangeMax=\"12\">\n");
    fprintf(myfile,"          ");
    for(int i=1;i<=iNEL;i++)
    {
      fprintf(myfile,"12 ");
      if(i%6==0)
      {
        fprintf(myfile,"\n");
        fprintf(myfile,"          ");
      }
    }

    if(iNEL%6!=0)	fprintf(myfile,"\n");
    fprintf(myfile,"        </DataArray>\n");

    //finish the cells and the piece
    fprintf(myfile,"      </Cells>\n");
    fprintf(myfile,"    </Piece>\n");

    //add the finish tags
    fprintf(myfile,"  </UnstructuredGrid>\n");
    fprintf(myfile,"</VTKFile>\n");

    fclose( myfile );

  }

  void CVtkWriter::writeVtkMultiBlockFile(CUnstrGrid &Grid, const char * strFileName)
  {

    using namespace std;
    std::ostringstream sNameMain;
    sNameMain<<"output/multiblockdatafile.vtm";

    //open file for writing
    FILE * myfile = fopen(strFileName,"w");

//class ParFileInfo
//{
//  public:
//  std::string name_;
//  std::string expression_;
//  std::string boundaryType_;
//  std::vector<int> nodes_;
//  std::vector<HexaFace> verticesAtFace_;
//  std::vector<int> faces_;
//  unsigned size_;
//};  

    std::vector<ParFileInfo> &parFileList = *Grid.parInfo_;

    //Write the vtk header
    fprintf(myfile,"<?xml version=\"1.0\"?>\n");
    fprintf(myfile,"<VTKFile type=\"vtkMultiBlockDataSet\" version=\"1.0\" byte_order=\"LittleEndian\">\n");
    fprintf(myfile,"  <vtkMultiBlockDataSet>\n");

    for(unsigned bdr(0); bdr < parFileList.size(); ++bdr)
    {
      ParFileInfo &xx = parFileList[bdr];
      int nfaces = xx.faces_.size();

      std::ostringstream sName;
      sName << xx.name_ << ".vtu";
      //--------------------------------------------------------------------------
      fprintf(myfile,"    <Block index=\"%u\">\n",bdr);

      fprintf(myfile,"      <DataSet index=\"0\" file=\"%s\" name=\"%s-%s\"></DataSet>\n",sName.str().c_str(),xx.name_.c_str(), xx.boundaryType_.c_str());

      fprintf(myfile,"    </Block>\n");

      //--------------------------------------------------------------------------
    }

    fprintf(myfile,"    <Block index=\"%u\">\n",parFileList.size());

    fprintf(myfile,"      <DataSet index=\"0\" file=\"grid.vtu\" name=\"Mesh\"></DataSet>\n");

    fprintf(myfile,"    </Block>\n");

    fprintf(myfile,"  </vtkMultiBlockDataSet>\n");
    fprintf(myfile,"</VTKFile>\n");

    //close the stream
    fclose( myfile );

  }

  void CVtkWriter::WriteUnstrFacesSingleXML(CUnstrGrid &Grid, ParFileInfo & xx, const char *strFileName)
  {

    //open file for writing
    int nfaces = xx.faces_.size();

    FILE * myfile = fopen(strFileName,"w");

    std::string indentation("");
    std::string space("  ");

    if (myfile == NULL) {
      std::cout<<"Error opening file: "<<strFileName<<std::endl;
      std::exit(EXIT_FAILURE);
    }

    fprintf(myfile,"<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">\n");

    indentation.append(space);

    //Write the vtk header
    fprintf(myfile,"%s<UnstructuredGrid>\n",indentation.c_str());

    indentation.append(space);

    //Next item is the number of points and cells
    fprintf(myfile,"%s<Piece NumberOfPoints=\"%i\" NumberOfCells=\"%i\">\n",indentation.c_str(),Grid.nvt_,nfaces);

    indentation.append(space);

    //write the pointdata distance scalar
    fprintf(myfile,"%s<PointData Scalars=\"FFID\">\n",indentation.c_str());

    indentation.append(space);

    fprintf(myfile,"%s<DataArray type=\"Int32\" Name=\"FFID\" format=\"ascii\">\n",indentation.c_str());

    indentation.append(space);

    for(int i=0;i<Grid.nvt_;i++)
    {
      fprintf(myfile,"%s%d\n",indentation.c_str(),i+1);
    }//end for

    indentation.erase(indentation.size()-2,indentation.size());

    fprintf(myfile,"%s</DataArray>\n",indentation.c_str());

    fprintf(myfile,"%s</PointData>\n",indentation.c_str());

    indentation.erase(indentation.size()-2,indentation.size());

    //write the points data array to the file
    fprintf(myfile,"%s<Points>\n",indentation.c_str());

    indentation.append(space);

    fprintf(myfile,"%s<DataArray type=\"Float32\" Name=\"Points\" NumberOfComponents=\"3\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"1.0\">\n",indentation.c_str());

    indentation.append(space);

    for(int i=0;i<Grid.nvt_;i++)
    {
      fprintf(myfile,"%s%f %f %f\n",indentation.c_str(),Grid.vertexCoords_[i].x,Grid.vertexCoords_[i].y,Grid.vertexCoords_[i].z);
    }//end for

    indentation.erase(indentation.size()-2,indentation.size());

    fprintf(myfile,"%s</DataArray>\n",indentation.c_str());

    indentation.erase(indentation.size()-2,indentation.size());

    fprintf(myfile,"%s</Points>\n",indentation.c_str());

    indentation.append(space);

    //Next item is the cell data array
    fprintf(myfile,"%s<Cells>\n",indentation.c_str());

    indentation.append(space);

    fprintf(myfile,"%s<DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"%i\">\n",indentation.c_str(),Grid.nvt_-1);

    indentation.append(space);

    for(int i=0;i<nfaces;i++)
    {
      int i0 = xx.verticesAtFace_[i].faceVertexIndices_[0];
      int i1 = xx.verticesAtFace_[i].faceVertexIndices_[1];
      int i2 = xx.verticesAtFace_[i].faceVertexIndices_[2];
      int i3 = xx.verticesAtFace_[i].faceVertexIndices_[3];
      fprintf(myfile,"%s%i %i %i %i\n",indentation.c_str(),i0,i1,i2,i3);
    }//end for

    indentation.erase(indentation.size()-2,indentation.size());

    fprintf(myfile,"%s</DataArray>\n",indentation.c_str());

    //the offset seems to be mandatory
    fprintf(myfile,"%s<DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\" RangeMin=\"4\" RangeMax=\"%i\">\n",indentation.c_str(),nfaces*4);

    indentation.append(space);

    fprintf(myfile,"%s",indentation.c_str());

    for(int i=1;i<=nfaces;i++)
    {
      fprintf(myfile,"%i ",i*4);
      if(i%6==0)
      {
        fprintf(myfile,"\n");
        fprintf(myfile,"%s",indentation.c_str());
      }
    }

    if(nfaces%6!=0)fprintf(myfile,"\n");

    indentation.erase(indentation.size()-2,indentation.size());

    fprintf(myfile,"%s</DataArray>\n",indentation.c_str());

    //add a data array with the types of the cells
    fprintf(myfile,"%s<DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\" RangeMin=\"9\" RangeMax=\"9\">\n",indentation.c_str());

    indentation.append(space);

    fprintf(myfile,"%s",indentation.c_str());

    for(int i=1;i<=nfaces;i++)
    {
      fprintf(myfile,"9 ");
      if(i%6==0)
      {
        fprintf(myfile,"\n");
        fprintf(myfile,"%s",indentation.c_str());
      }
    }

    if(Grid.nel_%6!=0)	fprintf(myfile,"\n");

    indentation.erase(indentation.size()-2,indentation.size());

    fprintf(myfile,"%s</DataArray>\n",indentation.c_str());

    indentation.erase(indentation.size()-2,indentation.size());

    //finish the cells and the piece
    fprintf(myfile,"%s</Cells>\n",indentation.c_str());

    indentation.erase(indentation.size()-2,indentation.size());

    fprintf(myfile,"%s</Piece>\n",indentation.c_str());

    indentation.erase(indentation.size()-2,indentation.size());

    //add the finish tags
    fprintf(myfile,"%s</UnstructuredGrid>\n",indentation.c_str());

    indentation.erase(indentation.size()-2,indentation.size());

    fprintf(myfile,"</VTKFile>\n");

    fclose( myfile );

  }

  void CVtkWriter::WriteUnstrFacesXML(CUnstrGrid &Grid,const char *strFileName)
  {

    //open file for writing
    std::vector<ParFileInfo> &parFileList = *Grid.parInfo_;
    for(unsigned bdr(0); bdr < Grid.parInfo_->size(); ++bdr)
    {
      ParFileInfo &xx = parFileList[bdr];
      int nfaces = xx.faces_.size();

      std::ostringstream sName;
      sName << strFileName << xx.name_ << ".vtu";

      FILE * myfile = fopen(sName.str().c_str(),"w");

      std::string indentation("");
      std::string space("  ");

      if (myfile == NULL) {
        std::cout<<"Error opening file: "<<strFileName<<std::endl;
        std::exit(EXIT_FAILURE);
      }

      int _nvt = xx.nodes_.size();

      fprintf(myfile,"<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">\n");

      indentation.append(space);

      //Write the vtk header
      fprintf(myfile,"%s<UnstructuredGrid>\n",indentation.c_str());

      indentation.append(space);

      //Next item is the number of points and cells
      fprintf(myfile,"%s<Piece NumberOfPoints=\"%i\" NumberOfCells=\"%i\">\n",indentation.c_str(),_nvt,nfaces);

      indentation.append(space);

      //write the pointdata distance scalar
      fprintf(myfile,"%s<PointData Scalars=\"FFID\">\n",indentation.c_str());

      indentation.append(space);

      fprintf(myfile,"%s<DataArray type=\"Int32\" Name=\"FFID\" format=\"ascii\">\n",indentation.c_str());

      indentation.append(space);

      for(int i=0;i<_nvt;i++)
      {
        int id = xx.nodes_[i] + 1;
        fprintf(myfile,"%s%d\n",indentation.c_str(),id);
      }//end for

      indentation.erase(indentation.size()-2,indentation.size());

      fprintf(myfile,"%s</DataArray>\n",indentation.c_str());

  //    fprintf(myfile,"%s<DataArray type=\"Int32\" Name=\"BMF\" format=\"ascii\">\n",indentation.c_str());
  //
  //    indentation.append(space);
  //
  //    for(int i=0;i<Grid.nvt_;i++)
  //    {
  //      fprintf(myfile,"%s%d \n",indentation.c_str(),Grid.verticesAtBoundary_[i]);
  //    }//end for
  //
  //    indentation.erase(indentation.size()-2,indentation.size());
  //
  //    fprintf(myfile,"%s</DataArray>\n",indentation.c_str());
  //
  //    indentation.erase(indentation.size()-2,indentation.size());

      fprintf(myfile,"%s</PointData>\n",indentation.c_str());

      indentation.erase(indentation.size()-2,indentation.size());

      //write the points data array to the file
      fprintf(myfile,"%s<Points>\n",indentation.c_str());

      indentation.append(space);

      fprintf(myfile,"%s<DataArray type=\"Float32\" Name=\"Points\" NumberOfComponents=\"3\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"1.0\">\n",indentation.c_str());

      indentation.append(space);

      for(int i=0;i<_nvt;i++)
      {

        int id = xx.nodes_[i]-1;
        fprintf(myfile,"%s%f %f %f\n",
            indentation.c_str(),
            Grid.vertexCoords_[id].x,
            Grid.vertexCoords_[id].y,
            Grid.vertexCoords_[id].z);

      }//end for

      indentation.erase(indentation.size()-2,indentation.size());

      fprintf(myfile,"%s</DataArray>\n",indentation.c_str());

      indentation.erase(indentation.size()-2,indentation.size());

      fprintf(myfile,"%s</Points>\n",indentation.c_str());

      indentation.append(space);

      //Next item is the cell data array
      fprintf(myfile,"%s<Cells>\n",indentation.c_str());

      indentation.append(space);

      fprintf(myfile,"%s<DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"%i\">\n",indentation.c_str(),Grid.nvt_-1);

      indentation.append(space);

      for(int i=0;i<nfaces;i++)
      {
        int ii0 = xx.verticesAtFace_[i].faceVertexIndices_[0];
        int ii1 = xx.verticesAtFace_[i].faceVertexIndices_[1];
        int ii2 = xx.verticesAtFace_[i].faceVertexIndices_[2];
        int ii3 = xx.verticesAtFace_[i].faceVertexIndices_[3];

        int i0 = xx.glob2Loc_[ii0];
        int i1 = xx.glob2Loc_[ii1];
        int i2 = xx.glob2Loc_[ii2];
        int i3 = xx.glob2Loc_[ii3];


        fprintf(myfile,"%s%i %i %i %i\n",indentation.c_str(),i0,i1,i2,i3);
      }//end for

      indentation.erase(indentation.size()-2,indentation.size());

      fprintf(myfile,"%s</DataArray>\n",indentation.c_str());

      //the offset seems to be mandatory
      fprintf(myfile,"%s<DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\" RangeMin=\"4\" RangeMax=\"%i\">\n",indentation.c_str(),nfaces*4);

      indentation.append(space);

      fprintf(myfile,"%s",indentation.c_str());

      for(int i=1;i<=nfaces;i++)
      {
        fprintf(myfile,"%i ",i*4);
        if(i%6==0)
        {
          fprintf(myfile,"\n");
          fprintf(myfile,"%s",indentation.c_str());
        }
      }

      if(nfaces%6!=0)fprintf(myfile,"\n");

      indentation.erase(indentation.size()-2,indentation.size());

      fprintf(myfile,"%s</DataArray>\n",indentation.c_str());

      //add a data array with the types of the cells
      fprintf(myfile,"%s<DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\" RangeMin=\"9\" RangeMax=\"9\">\n",indentation.c_str());

      indentation.append(space);

      fprintf(myfile,"%s",indentation.c_str());

      for(int i=1;i<=nfaces;i++)
      {
        fprintf(myfile,"9 ");
        if(i%6==0)
        {
          fprintf(myfile,"\n");
          fprintf(myfile,"%s",indentation.c_str());
        }
      }

      if(Grid.nel_%6!=0)	fprintf(myfile,"\n");

      indentation.erase(indentation.size()-2,indentation.size());

      fprintf(myfile,"%s</DataArray>\n",indentation.c_str());

      indentation.erase(indentation.size()-2,indentation.size());

      //finish the cells and the piece
      fprintf(myfile,"%s</Cells>\n",indentation.c_str());

      indentation.erase(indentation.size()-2,indentation.size());

      fprintf(myfile,"%s</Piece>\n",indentation.c_str());

      indentation.erase(indentation.size()-2,indentation.size());

      //add the finish tags
      fprintf(myfile,"%s</UnstructuredGrid>\n",indentation.c_str());

      indentation.erase(indentation.size()-2,indentation.size());

      fprintf(myfile,"</VTKFile>\n");

      fclose( myfile );

    }


  }

  void CVtkWriter::WriteUnstrXML(CUnstrGrid &Grid, const char * strFileName)
  {
    using namespace std;
    int iRangeMin,iRangeMax;

    //open file for writing
    FILE * myfile = fopen(strFileName,"w");

    std::string indentation("");
    std::string space("  ");

    if (myfile == NULL) {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }

    fprintf(myfile,"<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">\n");

    indentation.append(space);

    //Write the vtk header
    fprintf(myfile,"%s<UnstructuredGrid>\n",indentation.c_str());

    indentation.append(space);

    //Next item is the number of points and cells
    fprintf(myfile,"%s<Piece NumberOfPoints=\"%i\" NumberOfCells=\"%i\">\n",indentation.c_str(),Grid.nvt_,Grid.nel_);

    indentation.append(space);

    //write the pointdata distance scalar
    fprintf(myfile,"%s<PointData Scalars=\"FFID\">\n",indentation.c_str());

    indentation.append(space);

    fprintf(myfile,"%s<DataArray type=\"Int32\" Name=\"FFID\" format=\"ascii\">\n",indentation.c_str());

    indentation.append(space);

    for(int i=0;i<Grid.nvt_;i++)
    {
      fprintf(myfile,"%s%d\n",indentation.c_str(),i+1);
    }//end for

    indentation.erase(indentation.size()-2,indentation.size());

    fprintf(myfile,"%s</DataArray>\n",indentation.c_str());

//    fprintf(myfile,"%s<DataArray type=\"Float32\" Name=\"Distance\" format=\"ascii\">\n",indentation.c_str());
//
//    indentation.append(space);
//
//    for(int i=0;i<Grid.nvt_;i++)
//    {
//      fprintf(myfile,"%s%f\n",indentation.c_str(),Grid.m_myTraits[i].distance);
//    }//end for
//
//    indentation.erase(indentation.size()-2,indentation.size());
//
//    fprintf(myfile,"%s</DataArray>\n",indentation.c_str());
//
//    //write the pointdata distance scalar
//    fprintf(myfile,"%s<DataArray type=\"Float32\" Name=\"dist2\" format=\"ascii\">\n",indentation.c_str());
//
//    indentation.append(space);
//
//    for(int i=0;i<Grid.nvt_;i++)
//    {
//      fprintf(myfile,"%s%f\n",indentation.c_str(),Grid.m_myTraits[i].dist2);
//    }//end for
//
//    indentation.erase(indentation.size()-2,indentation.size());
//
//    fprintf(myfile,"%s</DataArray>\n",indentation.c_str());
//
//    //write the pointdata distance scalar
//    fprintf(myfile,"%s<DataArray type=\"Float32\" Name=\"FBM\" format=\"ascii\">\n",indentation.c_str());
//
//    indentation.append(space);
//
//    for(int i=0;i<Grid.nvt_;i++)
//    {
//      fprintf(myfile,"%s%f \n",indentation.c_str(),double(Grid.m_myTraits[i].iTag));
//    }//end for
//
//    indentation.erase(indentation.size()-2,indentation.size());
//
//    fprintf(myfile,"%s</DataArray>\n",indentation.c_str());

    indentation.erase(indentation.size()-2,indentation.size());

    fprintf(myfile,"%s</PointData>\n",indentation.c_str());

    indentation.erase(indentation.size()-2,indentation.size());

    //write the points data array to the file
    fprintf(myfile,"%s<Points>\n",indentation.c_str());

    indentation.append(space);

    fprintf(myfile,"%s<DataArray type=\"Float32\" Name=\"Points\" NumberOfComponents=\"3\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"1.0\">\n",indentation.c_str());

    indentation.append(space);

    for(int i=0;i<Grid.nvt_;i++)
    {
      fprintf(myfile,"%s%f %f %f\n",indentation.c_str(),Grid.vertexCoords_[i].x,Grid.vertexCoords_[i].y,Grid.vertexCoords_[i].z);
    }//end for

    indentation.erase(indentation.size()-2,indentation.size());

    fprintf(myfile,"%s</DataArray>\n",indentation.c_str());

    indentation.erase(indentation.size()-2,indentation.size());

    fprintf(myfile,"%s</Points>\n",indentation.c_str());

    indentation.append(space);

    //Next item is the cell data array
    fprintf(myfile,"%s<Cells>\n",indentation.c_str());

    indentation.append(space);

    fprintf(myfile,"%s<DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"%i\">\n",indentation.c_str(),Grid.nel_-1);

    indentation.append(space);

    for(int i=0;i<Grid.nel_;i++)
    {
      fprintf(myfile,"%s%i %i %i %i %i %i %i %i\n",indentation.c_str(),Grid.hexas_[i].hexaVertexIndices_[0],
          Grid.hexas_[i].hexaVertexIndices_[1],Grid.hexas_[i].hexaVertexIndices_[2],
          Grid.hexas_[i].hexaVertexIndices_[3],Grid.hexas_[i].hexaVertexIndices_[4],
          Grid.hexas_[i].hexaVertexIndices_[5],Grid.hexas_[i].hexaVertexIndices_[6],Grid.hexas_[i].hexaVertexIndices_[7]);
    }

    indentation.erase(indentation.size()-2,indentation.size());

    fprintf(myfile,"%s</DataArray>\n",indentation.c_str());

    //the offset seems to be mandatory
    fprintf(myfile,"%s<DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\" RangeMin=\"8\" RangeMax=\"%i\">\n",indentation.c_str(),Grid.nel_*8);

    indentation.append(space);

    fprintf(myfile,"%s",indentation.c_str());

    for(int i=1;i<=Grid.nel_;i++)
    {
      fprintf(myfile,"%i ",i*8);
      if(i%6==0)
      {
        fprintf(myfile,"\n");
        fprintf(myfile,"%s",indentation.c_str());
      }
    }

    if(Grid.nel_%6!=0)fprintf(myfile,"\n");

    indentation.erase(indentation.size()-2,indentation.size());

    fprintf(myfile,"%s</DataArray>\n",indentation.c_str());

    //add a data array with the types of the cells
    fprintf(myfile,"%s<DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\" RangeMin=\"12\" RangeMax=\"12\">\n",indentation.c_str());

    indentation.append(space);

    fprintf(myfile,"%s",indentation.c_str());

    for(int i=1;i<=Grid.nel_;i++)
    {
      fprintf(myfile,"12 ");
      if(i%6==0)
      {
        fprintf(myfile,"\n");
        fprintf(myfile,"%s",indentation.c_str());
      }
    }

    if(Grid.nel_%6!=0)	fprintf(myfile,"\n");

    indentation.erase(indentation.size()-2,indentation.size());

    fprintf(myfile,"%s</DataArray>\n",indentation.c_str());

    indentation.erase(indentation.size()-2,indentation.size());

    //finish the cells and the piece
    fprintf(myfile,"%s</Cells>\n",indentation.c_str());

    indentation.erase(indentation.size()-2,indentation.size());

    fprintf(myfile,"%s</Piece>\n",indentation.c_str());

    indentation.erase(indentation.size()-2,indentation.size());

    //add the finish tags
    fprintf(myfile,"%s</UnstructuredGrid>\n",indentation.c_str());

    indentation.erase(indentation.size()-2,indentation.size());

    fprintf(myfile,"</VTKFile>\n");

    fclose( myfile );
  }


  void CVtkWriter::WriteBasf(std::vector<Model3D> &pModels,const char *strFileName)
  {
    using namespace std;
    ofstream myfile(strFileName);

    //total number of vertices
    int iVerts=0;
    //total number of polygons
    int iPolys=0;
    //iterators for models and submeshes
    vector<Mesh3D>::iterator meshIter;
    vector<Model3D>::iterator modelIter;
    vector<int> vVerts;
    vector<int>::iterator vertsIter;
    int ioffset=0;

    //check
    if(!myfile.is_open())
    {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }//end if

    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      int ivertsModel=0;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        iVerts+=pMesh.numVerts_;
        iPolys+=pMesh.numFaces_;
        ivertsModel+=pMesh.numVerts_;
      }
      vVerts.push_back(ivertsModel);
    }

    myfile<<"# vtk DataFile Version 2.0"<<endl;
    myfile<<"Generated by InShape 2.x"<<endl;
    myfile<<"ASCII"<<endl;
    myfile<<"DATASET POLYDATA"<<endl;
    myfile<<"POINTS "<<iVerts<<" double"<<endl;
    myfile.precision(7);
    //write the actual vertex data
    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.vertices_.size();i++)
        {
          myfile<<pMesh.vertices_[i].x<<" "<<pMesh.vertices_[i].y<<" "<<pMesh.vertices_[i].z<<endl;
        }//end for
      }//for
    }//end for

    int lengthPolyList=4*iPolys;
    myfile<<"POLYGONS "<<iPolys<<" "<<lengthPolyList<<endl;
    vertsIter = vVerts.begin();
    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      int ivertsModel = *vertsIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.numFaces_;i++)
        {
          int a=pMesh.faces_[i][0]+ioffset;
          int b=pMesh.faces_[i][1]+ioffset;
          int c=pMesh.faces_[i][2]+ioffset;
          myfile<<3<<" "<<pMesh.faces_[i][0]+ioffset<<" "
            <<pMesh.faces_[i][1]+ioffset<<" "<<pMesh.faces_[i][2]+ioffset<<endl;
        }//end for faces
        ioffset+=1343;
      }//for submeshes
      vertsIter++;
    }//for models

    myfile<<"CELL_DATA "<<iPolys<<endl;
    myfile<<"SCALARS "<<"CellID int 1"<<endl;
    myfile<<"LOOKUP_TABLE default"<<endl;

    int iModel=0;
    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        //cout<<"Collision state: "<<body.m_iCollisionState<<endl;
        for(int i=0;i<pMesh.numFaces_;i++)
        {
          myfile<<iModel<<endl;
        }//end for faces
      }//for submeshes
      iModel++;
    }//for models	

  }//end function

  void CVtkWriter::WriteContacts(std::vector<Contact> &vContacts, const char* strFileName)
  {
    using namespace std;
    std::vector<Contact>::iterator cIter;

    int nContacts = vContacts.size();

    //open the file
    ofstream myfile0(strFileName);

    //check
    if(!myfile0.is_open())
    {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }//end if

    myfile0<<"# vtk DataFile Version 2.0"<<endl;
    myfile0<<"Generated by InShape 2.x"<<endl;
    myfile0<<"ASCII"<<endl;
    myfile0<<"DATASET POLYDATA"<<endl;
    myfile0<<"POINTS "<<2*vContacts.size()<<" double"<<endl;
    myfile0.precision(7);

    for(cIter=vContacts.begin();cIter<vContacts.end();cIter++)
    {
      Contact contact = *cIter;
      contact.m_vNormal *= 0.05;
      myfile0<<contact.m_vPosition0.x<<" "<<contact.m_vPosition0.y<<" "<<contact.m_vPosition0.z<<endl;
      myfile0<<contact.m_vPosition0.x+contact.m_vNormal.x<<
        " "<<contact.m_vPosition0.y+contact.m_vNormal.y<<
        " "<<contact.m_vPosition0.z+contact.m_vNormal.z<<endl;
    }//end for

    myfile0<<"LINES "<<nContacts<<" "<<nContacts*3<<endl;
    for(int i=0;i<2*nContacts;i+=2)
    {
      myfile0<<2<<" "<<i<<" "<<i+1<<endl;
    }

    myfile0.close();
  }

  void CVtkWriter::WriteGPUParticleFile(std::vector<float> &pPos ,const char *strFileName)
  {

    using namespace std;
    FILE * myfile = fopen(strFileName,"w");

    if (myfile == NULL) {
      cout<<"Error opening file: "<<strFileName<<endl;
      std::exit(0);
    }

    int i,j;

    fprintf(myfile,"# vtk DataFile Version 2.0\n");
    fprintf(myfile,"Generated by InShape 2.x\n");
    fprintf(myfile,"ASCII\n");
    fprintf(myfile,"DATASET UNSTRUCTURED_GRID\n");

    //total number of vertices
    int iVerts=0;
    //total number of polygons
    int iPolys=0;
    //iterators for models and submeshes
    int ioffset=0;

    iVerts = pPos.size(); 

    fprintf(myfile,"POINTS %i double\n",iVerts/4);  

    for(int i(0); i < iVerts; i+=4)
    {
      fprintf(myfile,"%f %f %f \n",pPos[i],pPos[i+1],pPos[i+2]);      
    }

    fprintf(myfile,"POINT_DATA %i\n",iVerts/4);    
    fprintf(myfile,"SCALARS radius double 1\n");  
    fprintf(myfile,"LOOKUP_TABLE default\n");

    for(int i(0); i < iVerts; i+=4)
    {
      fprintf(myfile,"%f \n",1.0f/64.0f);      
    }


    fprintf(myfile,"SCALARS myid double 1\n");  
    fprintf(myfile,"LOOKUP_TABLE default\n");
    for(int i(0); i < iVerts/4; ++i)
    {
      fprintf(myfile,"%f \n",float(i));      
    }

    fclose( myfile );

  }

  void CVtkWriter::WriteParticleFile(std::vector<RigidBody*> &pRigidBodies,const char *strFileName)
  {

    using namespace std;
    FILE * myfile = fopen(strFileName,"w");

    if (myfile == NULL) {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }

    int i,j;

    fprintf(myfile,"# vtk DataFile Version 2.0\n");
    fprintf(myfile,"Generated by InShape 2.x\n");
    fprintf(myfile,"ASCII\n");
    fprintf(myfile,"DATASET UNSTRUCTURED_GRID\n");

    //total number of vertices
    int iVerts=0;
    //total number of polygons
    int iPolys=0;
    //iterators for models and submeshes
    vector<Mesh3D>::iterator meshIter;
    vector<Model3D>::iterator modelIter;
    vector<RigidBody*>::iterator rIter;
    vector<Model3D> pModels;
    vector<int> vVerts;
    vector<int>::iterator vertsIter;
    int ioffset=0;

    for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
    {
      RigidBody &body = *(*rIter);
      int id = body.shapeId_;
      if(body.shapeId_ == RigidBody::SPHERE)
      {
        iVerts++;
      }
      else if(body.shapeId_ == RigidBody::COMPOUND)
      {
        RigidBody *pBody = &body;
        CompoundBody *b = dynamic_cast<CompoundBody*>(pBody);
        iVerts += b->rigidBodies_.size();
      }
    }

    fprintf(myfile,"POINTS %i double\n",iVerts);  

    for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
    {
      RigidBody &body = *(*rIter);
      if(body.shapeId_ == RigidBody::SPHERE)
      {
        fprintf(myfile,"%f %f %f \n",body.com_.x,body.com_.y,body.com_.z);      
      }
      else if(body.shapeId_ == RigidBody::COMPOUND)
      {
        RigidBody *pBody = &body;
        CompoundBody *b = dynamic_cast<CompoundBody*>(pBody);
        for( auto &i : b->rigidBodies_)
        {
          RigidBody* comp = i;
          //MATRIX3X3 rot = body.getTransformationMatrix();
          //VECTOR3 trans = comp->com_ - body.com_;
          //trans = rot * trans;
          //trans += body.com_;
          VECTOR3 trans = comp->getTransformedPosition();
          fprintf(myfile, "%f %f %f \n", trans.x, trans.y, trans.z);
        }
      }
    }

    fprintf(myfile,"POINT_DATA %i\n",iVerts);    
    fprintf(myfile,"SCALARS radius double 1\n");  
    fprintf(myfile,"LOOKUP_TABLE default\n");
    for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
    {
      RigidBody &body = *(*rIter);
      if(body.shapeId_ == RigidBody::SPHERE)
      {
        fprintf(myfile,"%f\n",2.0*body.shape_->getAABB().extents_[0]);            
      }
      else if(body.shapeId_ == RigidBody::COMPOUND)
      {
        RigidBody *pBody = &body;
        CompoundBody *b = dynamic_cast<CompoundBody*>(pBody);
        for( auto &i : b->rigidBodies_)
        {
          RigidBody* comp = i;
          fprintf(myfile,"%f\n",2.0*comp->shape_->getAABB().extents_[0]);
        }
      }
    }

    fprintf(myfile,"SCALARS color double 1\n");  
    fprintf(myfile,"LOOKUP_TABLE default\n");
    for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
    {
      RigidBody &body = *(*rIter);
      if(body.shapeId_ == RigidBody::SPHERE)
      {
        fprintf(myfile,"%f\n",body.color_);            
      }
      else if(body.shapeId_ == RigidBody::COMPOUND)
      {
        RigidBody *pBody = &body;
        CompoundBody *b = dynamic_cast<CompoundBody*>(pBody);
        for( auto &i : b->rigidBodies_)
        {
          RigidBody* comp = i;
          fprintf(myfile,"%f\n",comp->color_);
        }
      }
    }

    fprintf(myfile,"SCALARS particleID int 1\n");  
    fprintf(myfile,"LOOKUP_TABLE default\n");
    for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
    {
      RigidBody &body = *(*rIter);
      if(body.shapeId_ == RigidBody::SPHERE)
      {
        fprintf(myfile,"%d\n",body.iID_);            
      }
      else if(body.shapeId_ == RigidBody::COMPOUND)
      {
        RigidBody *pBody = &body;
        CompoundBody *b = dynamic_cast<CompoundBody*>(pBody);
        for( auto &i : b->rigidBodies_)
        {
          RigidBody* comp = i;
          fprintf(myfile,"%d\n",comp->iID_);
        }
      }
    }

    fclose( myfile );

  }

  void CVtkWriter::WriteSphereFile(std::vector<Spherer> &spheres, const char *strFileName)
  {

    using namespace std;
    FILE * myfile = fopen(strFileName, "w");

    if (myfile == NULL) {
      cout << "Error opening file: " << strFileName << endl;
      exit(0);
    }

    int i, j;

    fprintf(myfile, "# vtk DataFile Version 2.0\n");
    fprintf(myfile, "Generated by InShape 2.x\n");
    fprintf(myfile, "ASCII\n");
    fprintf(myfile, "DATASET UNSTRUCTURED_GRID\n");

    //total number of vertices
    int iVerts = 0;
    //iterators for models and submeshes
    int ioffset = 0;

    iVerts = spheres.size();

    fprintf(myfile, "POINTS %i double\n", iVerts);

    for (auto &sphere : spheres)
    {
      fprintf(myfile, "%f %f %f \n", sphere.center_.x, sphere.center_.y, sphere.center_.z);
    }

    fprintf(myfile, "POINT_DATA %i\n", iVerts);
    fprintf(myfile, "SCALARS radius double 1\n");
    fprintf(myfile, "LOOKUP_TABLE default\n");
    for (auto &sphere : spheres)
    {
      fprintf(myfile, "%f\n", 2.0*sphere.getRadius());
    }

    fclose(myfile);
  }

  void CVtkWriter::WriteCompound(std::vector<RigidBody*> &pRigidBodies, World *world, const char *strFileName)
  {

    using namespace std;
    FILE * myfile = fopen(strFileName,"w");

    if (myfile == NULL) {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }

    int i,j;

    fprintf(myfile,"# vtk DataFile Version 2.0\n");
    fprintf(myfile,"Generated by InShape 2.x\n");
    fprintf(myfile,"ASCII\n");
    fprintf(myfile,"DATASET UNSTRUCTURED_GRID\n");

    //total number of vertices
    int iVerts=0;
    //total number of polygons
    int iPolys=0;
    //iterators for models and submeshes
    vector<Mesh3D>::iterator meshIter;
    vector<Model3D>::iterator modelIter;
    vector<RigidBody*>::iterator rIter;
    vector<Model3D> pModels;
    vector<int> vVerts;
    vector<int>::iterator vertsIter;
    int ioffset=0;

    for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
    {
      RigidBody &body = *(*rIter);
      int id = body.shapeId_;
      if(body.shapeId_ == RigidBody::SPHERE)
      {
        iVerts++;
      }
      else if(body.shapeId_ == RigidBody::COMPOUND)
      {
        iVerts++;
      }
    }

    fprintf(myfile,"POINTS %i double\n",iVerts);

    for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
    {
      RigidBody &body = *(*rIter);
      if(body.shapeId_ == RigidBody::SPHERE)
      {
        fprintf(myfile,"%f %f %f \n",body.com_.x,body.com_.y,body.com_.z);
      }
      else if(body.shapeId_ == RigidBody::COMPOUND)
      {
        RigidBody *pBody = &body;
        CompoundBody *b = dynamic_cast<CompoundBody*>(pBody);
        VECTOR3 trans = b->com_;
        fprintf(myfile, "%f %f %f \n", trans.x, trans.y, trans.z);
      }
    }

    fprintf(myfile,"POINT_DATA %i\n",iVerts);
    fprintf(myfile,"VECTORS Normal double\n");
    std::vector<CollisionInfo*> contacts;
    CollisionHash::iterator hiter =  world->graph_->edges_->begin();
    int normals = 0;
    for (; hiter != world->graph_->edges_->end(); hiter++)
    {
      CollisionInfo &info = *hiter;
      std::vector<Contact>::iterator iter;

      for (iter = info.m_vContacts.begin(); iter != info.m_vContacts.end(); iter++)
      {
        Contact &contact = *iter;
        if (contact.m_iState != CollisionInfo::TOUCHING)
          continue;

        if ((contact.type0 == RigidBody::MESH) && (contact.type1 == RigidBody::COMPOUND)&&(normals==0))
        {
          contact.m_vNormal;
          fprintf(myfile,"%f %f %f \n",contact.m_vNormal.x,contact.m_vNormal.y,contact.m_vNormal.z);
          normals++;
        }
      }
    }
    if(normals==0)
    {
      fprintf(myfile,"%f %f %f \n",0.0,0.0,0.0);
    }

    fprintf(myfile,"VECTORS vel double\n");
    for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
    {
      RigidBody &body = *(*rIter);
      if(body.shapeId_ == RigidBody::SPHERE)
      {
        fprintf(myfile,"%f\n",2.0*body.shape_->getAABB().extents_[0]);
      }
      else if(body.shapeId_ == RigidBody::COMPOUND)
      {
        RigidBody *pBody = &body;
        CompoundBody *b = dynamic_cast<CompoundBody*>(pBody);
        fprintf(myfile,"%f %f %f\n",b->velocity_.x,b->velocity_.y,b->velocity_.z);
      }
    }

    MATRIX3X3 rot;
    for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
    {
      RigidBody &body = *(*rIter);
      if(body.shapeId_ == RigidBody::SPHERE)
      {

      }
      else if(body.shapeId_ == RigidBody::COMPOUND)
      {
        RigidBody *pBody = &body;
        CompoundBody *b = dynamic_cast<CompoundBody*>(pBody);
        rot = b->getQuaternion().GetMatrix();
      }
    }

    fprintf(myfile,"VECTORS X double\n");
    VECTOR3 x(1,0,0);
    VECTOR3 y(0,1,0);
    VECTOR3 z(0,0,1);
    VECTOR3 t = rot*x;
    fprintf(myfile,"%f %f %f\n",t.x,t.y,t.z);
    fprintf(myfile,"VECTORS Y double\n");
    t = rot*y;
    fprintf(myfile,"%f %f %f\n",t.x,t.y,t.z);
    fprintf(myfile,"VECTORS Z double\n");
    t = rot*z;
    fprintf(myfile,"%f %f %f\n",t.x,t.y,t.z);

    fprintf(myfile,"SCALARS radius double 1\n");
    fprintf(myfile,"LOOKUP_TABLE default\n");
    for(rIter=pRigidBodies.begin();rIter!=pRigidBodies.end();rIter++)
    {
      RigidBody &body = *(*rIter);
      if(body.shapeId_ == RigidBody::SPHERE)
      {
        fprintf(myfile,"%f\n",2.0*body.shape_->getAABB().extents_[0]);
      }
      else if(body.shapeId_ == RigidBody::COMPOUND)
      {
        RigidBody *pBody = &body;
        CompoundBody *b = dynamic_cast<CompoundBody*>(pBody);
        fprintf(myfile,"%f\n",2.0*b->getBoundingSphereRadius());
      }
    }

    fclose( myfile );
  }

  void CVtkWriter::WriteUniformGrid(UniformGrid< Real, ElementCell > &grid, const char* strFileName)
  {
    using namespace std;
    ofstream myfile(strFileName);

    //check
    if(!myfile.is_open())
    {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }//end if

    int i,j;
    myfile<<"# vtk DataFile Version 2.0\n";
    myfile<<"Generated by FullC0ntact\n";
    myfile<<"ASCII\n";
    myfile<<"DATASET STRUCTURED_POINTS\n";
    myfile<<"DIMENSIONS "<<int((2.0*grid.m_bxBox.extents_[0]+grid.m_dCellSize)/grid.m_dCellSize)+1<<
      " "<<int((2.0*grid.m_bxBox.extents_[1]+grid.m_dCellSize)/grid.m_dCellSize)+1<<
      " "<<int((2.0*grid.m_bxBox.extents_[2]+grid.m_dCellSize)/grid.m_dCellSize)+1<<"\n";
    VECTOR3 center = grid.m_bxBox.getCenter() - VECTOR3(grid.m_bxBox.extents_[0],grid.m_bxBox.extents_[1],grid.m_bxBox.extents_[2]);
    myfile<<"ORIGIN "<<center.x<<" "<<center.y<<" "<<center.z<<"\n";
    myfile<<"SPACING "<<grid.m_dCellSize<<" "<<grid.m_dCellSize<<" "<<grid.m_dCellSize<<"\n";  

    myfile.close(); 
  }

  void CVtkWriter::WriteUniformGrid2(UniformGrid< Real, ElementCell, VertexTraits<Real> > &grid, const char* strFileName)
  {
    using namespace std;
    ofstream myfile(strFileName);

    //check
    if(!myfile.is_open())
    {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }//end if

    Vector3<Real> origin(grid.m_bxBox.center_.x-grid.m_bxBox.extents_[0],
        grid.m_bxBox.center_.y-grid.m_bxBox.extents_[1],
        grid.m_bxBox.center_.z-grid.m_bxBox.extents_[2]);

    int i,j;
    int cells = grid.m_iDimension[0]*grid.m_iDimension[1]*grid.m_iDimension[2]; 
    int points = (grid.m_iDimension[0]+1)*(grid.m_iDimension[1]+1)*(grid.m_iDimension[2]+1); 

    myfile<<"# vtk DataFile Version 2.0\n";
    myfile<<"Generated by FullC0ntact\n";
    myfile<<"ASCII\n";
    myfile<<"DATASET STRUCTURED_POINTS\n";
    myfile<<"DIMENSIONS "<<grid.m_iDimension[0]+1<<
      " "<<grid.m_iDimension[1]+1<<
      " "<<grid.m_iDimension[2]+1<<"\n";
    myfile<<"SPACING "<<grid.m_dCellSize<<" "<<grid.m_dCellSize<<" "<<grid.m_dCellSize<<"\n";  
    myfile<<"ORIGIN "<<origin.x<<" "<<origin.y<<" "<<origin.z<<"\n";
    myfile<<"POINT_DATA "<<points<<endl;
    myfile<<"SCALARS fbmv double "<<"\n";  
    myfile<<"LOOKUP_TABLE default\n";
    for(i=0;i<points;i++)
    {
      myfile<<grid.traits_.fbmVertices_[i]<<"\n";
    }//end for

    myfile<<"CELL_DATA "<<cells<<endl;
    myfile<<"SCALARS fbm double "<<"\n";  
    myfile<<"LOOKUP_TABLE default\n";
    for(i=0;i<cells;i++)
    {
      myfile<<grid.traits_.fbm_[i]<<"\n";
    }//end for

    myfile.close(); 
  }


#ifdef WITH_ODE
  void CVtkWriter::WriteODE2VTK(std::vector<BodyODE>& bodies, const char * strFileName)
  {

    using namespace std;

    FILE * myfile = fopen(strFileName,"w");

    if (myfile == nullptr) {
      cout<<"Error opening file: "<<strFileName<<endl;
      std::exit(EXIT_FAILURE);
    }

    //total number of vertices
    int iVerts=0;
    //total number of polygons
    int iPolys=0;
    //iterators for models and submeshes
    vector<Mesh3D>::iterator meshIter;
    vector<Model3D>::iterator modelIter;
    vector<RigidBody*>::iterator rIter;
    vector<Model3D> pModels;
    vector<int> vVerts;
    vector<int>::iterator vertsIter;
    int ioffset=0;

    for (auto &body : bodies)
    {

      int gId = dGeomGetClass(body._geomId);

      if (gId == dSphereClass)
      {
        const dReal *SPos = dBodyGetPosition(body._bodyId);
        const dReal *SRot = dBodyGetRotation(body._bodyId);
        float spos[3] = {SPos[0], SPos[1], SPos[2]};
        float srot[12] = { SRot[0], SRot[1], SRot[2], SRot[3], SRot[4], SRot[5], SRot[6], SRot[7], SRot[8], SRot[9], SRot[10], SRot[11] };

        CTriangulator<Real, Sphere<Real> > triangulator;

        Real rad = Real(dGeomSphereGetRadius(body._geomId));

        Spherer Sphere(Vec3(0,0,0),rad);
        
        Model3D model_out=triangulator.Triangulate(&Sphere);

        double entries[9] = { SRot[0], SRot[1], SRot[2], /* */ SRot[4], SRot[5], SRot[6], /* */ SRot[8], SRot[9], SRot[10] };

        MATRIX3X3 transform(entries);
        model_out.meshes_[0].transform_ = transform;
        model_out.meshes_[0].com_ = Vec3(SPos[0], SPos[1], SPos[2]);
        model_out.meshes_[0].TransformModelWorld();
        pModels.push_back(model_out);
      }
      else if (gId == dPlaneClass)
      {
        dVector4 v;
        dGeomPlaneGetParams(body._geomId, v);
        Planer pl(v[0], v[1], v[2], v[3]);

        CTriangulator<Real, Plane<Real> > triangulator;
        Model3D model_out=triangulator.Triangulate(pl);
        pModels.push_back(model_out);
      }
      else if (gId == dBoxClass)
      {
        const dReal *SPos = dBodyGetPosition(body._bodyId);
        const dReal *SRot = dBodyGetRotation(body._bodyId);
        float spos[3] = {SPos[0], SPos[1], SPos[2]};
        float srot[12] = { SRot[0], SRot[1], SRot[2], SRot[3], SRot[4], SRot[5], SRot[6], SRot[7], SRot[8], SRot[9], SRot[10], SRot[11] };

        CTriangulator<Real, OBB3<Real> > triangulator;

        dVector3 dim;
        dGeomBoxGetLengths(body._geomId, dim);
        
        OBB3r box(Vec3(0, 0, 0), Vec3(1, 0, 0), Vec3(0, 1, 0), Vec3(0, 0, 1), 0.5 * dim[0], 0.5 * dim[1], 0.5 * dim[2]); 
        
        Model3D model_out=triangulator.Triangulate(box);

        double entries[9] = { SRot[0], SRot[1], SRot[2], /* */ SRot[4], SRot[5], SRot[6], /* */ SRot[8], SRot[9], SRot[10] };

        MATRIX3X3 transform(entries);
        model_out.meshes_[0].transform_ = transform;
        model_out.meshes_[0].com_ = Vec3(SPos[0], SPos[1], SPos[2]);
        model_out.meshes_[0].TransformModelWorld();

        pModels.push_back(model_out);
      }
      else if (gId == dCylinderClass)
      {
        const dReal *SPos = dBodyGetPosition(body._bodyId);
        const dReal *SRot = dBodyGetRotation(body._bodyId);
        float spos[3] = {SPos[0], SPos[1], SPos[2]};
        float srot[12] = { SRot[0], SRot[1], SRot[2], 
                           SRot[3], SRot[4], SRot[5], 
                           SRot[6], SRot[7], SRot[8], 
                           SRot[9], SRot[10], SRot[11] };

        CTriangulator<Real, Cylinder<Real> > triangulator;

        dReal radius, l;
        dGeomCylinderGetParams(body._geomId, &radius, &l);
        
        Cylinderr cyl(Vec3(0,0,0),
                      Vec3(0,0,1),
                      radius, 0.5 * l);

        
        Model3D model_out=triangulator.Triangulate(cyl);

        double entries[9] = { SRot[0], SRot[1], SRot[2], /* */ 
                              SRot[4], SRot[5], SRot[6], /* */ 
                              SRot[8], SRot[9], SRot[10] };

        MATRIX3X3 transform(entries);
        model_out.meshes_[0].transform_ = transform;
        model_out.meshes_[0].com_ = Vec3(SPos[0], SPos[1], SPos[2]);
        model_out.meshes_[0].TransformModelWorld();

        pModels.push_back(model_out);
      }
    }

    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      int ivertsModel=0;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        iVerts+=pMesh.numVerts_;
        iPolys+=pMesh.numFaces_;
        ivertsModel+=pMesh.numVerts_;
      }
      vVerts.push_back(ivertsModel);
    }

    fprintf(myfile,"# vtk DataFile Version 2.0\n");
    fprintf(myfile,"Generated by InShape 2.x\n");
    fprintf(myfile,"ASCII\n");
    fprintf(myfile,"DATASET POLYDATA\n");
    fprintf(myfile,"POINTS %i double\n",iVerts);

    int count=0;
    //write the actual vertex data
    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.vertices_.size();i++)
        {
          fprintf(myfile,"%f %f %f \n",pMesh.vertices_[i].x,pMesh.vertices_[i].y,pMesh.vertices_[i].z);
        }//end for
      }//for
      count++;
    }//end for

    int lengthPolyList=4*iPolys;
    fprintf(myfile,"POLYGONS %i %i \n",iPolys,lengthPolyList);
    vertsIter = vVerts.begin();
    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      int ivertsModel = *vertsIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.numFaces_;i++)
        {
          TriFace &tri = pMesh.faces_[i];
          fprintf(myfile,"3 %i %i %i \n",tri[0]+ioffset, tri[1]+ioffset, tri[2]+ioffset);
        }//end for faces
        ioffset+=pMesh.numVerts_;
      }//for submeshes
      vertsIter++;
    }//for models

    fprintf(myfile,"POINT_DATA %i \n",iVerts);
    fprintf(myfile,"SCALARS dummy double 1 \n");
    fprintf(myfile,"LOOKUP_TABLE default\n");
    int modelid=0;
    for(modelIter = pModels.begin();modelIter!=pModels.end();modelIter++)
    {
      Model3D &pModel = *modelIter;
      for(meshIter=pModel.meshes_.begin();meshIter!=pModel.meshes_.end();meshIter++)
      {
        Mesh3D &pMesh=*meshIter;
        for(int i=0;i<pMesh.vertices_.size();i++)
        {
          fprintf(myfile,"%f\n",(pMesh.vertices_[0]-pMesh.vertices_[i]).mag());
        }//end for
      }//for
      modelid++;
    }//end for

    fclose (myfile);

  }
#endif 

  void CVtkWriter::WriteGJK(std::vector<VECTOR3> vertices, int iter, const char *strFileName)
  {
    using namespace std;
    ofstream myfile(strFileName);

    //check
    if(!myfile.is_open())
    {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }//end if

    int i,j;
    myfile<<"# vtk DataFile Version 2.0\n";
    myfile<<"Generated by FullC0ntact\n";
    myfile<<"ASCII\n";
    myfile<<"DATASET UNSTRUCTURED_GRID"<<endl;
    myfile<<"POINTS "<<vertices.size()<<" double"<<endl;
    myfile.precision(7);
    for(i=0;i<vertices.size();i++)
    {
      myfile<<vertices[i].x<<" "<<vertices[i].y<<" "<<vertices[i].z<<endl;
    }//end for

    myfile<<"CELLS "<<1<<" "<<vertices.size()+1<<endl;
    myfile<<vertices.size()<<" ";
    for(i=0;i<vertices.size();i++)
    {
      myfile<<i<<" ";
    }//end for

    myfile<<"\n";

    myfile<<"CELL_TYPES "<<1<<endl;

    int iverts = vertices.size();

    switch(iverts) {

      case 1:
        myfile<<1<<endl;
        break;
      case 2:
        myfile<<3<<endl;
        break;
      case 3:
        myfile<<5<<endl;
        break;
      case 4:
        myfile<<10<<endl;
        break;  
    }

    myfile.close();
  }

  void CVtkWriter::WriteMPR(std::vector<VECTOR3> vertices, int iter, const char *strFileName)
  {
    using namespace std;
    ofstream myfile(strFileName);

    //check
    if(!myfile.is_open())
    {
      cout<<"Error opening file: "<<strFileName<<endl;
      exit(0);
    }//end if

    int i,j;
    myfile<<"# vtk DataFile Version 2.0\n";
    myfile<<"Generated by FullC0ntact\n";
    myfile<<"ASCII\n";
    myfile<<"DATASET UNSTRUCTURED_GRID"<<endl;
    myfile<<"POINTS "<<vertices.size()<<" double"<<endl;
    myfile.precision(7);
    for(i=0;i<vertices.size();i++)
    {
      myfile<<vertices[i].x<<" "<<vertices[i].y<<" "<<vertices[i].z<<endl;
    }//end for

    myfile<<"CELLS "<<3<<" "<< 5 + 3 + 3<<endl;
    myfile<<4<<" ";
    for(i=0;i<4;i++)
    {
      myfile<<i<<" ";
    }//end for

    myfile<<"\n";

    myfile<<2<<" 0 4\n";  

    myfile<<2<<" 5 6\n";  

    myfile<<"CELL_TYPES "<<3<<endl;

    myfile<<10<<endl;

    myfile<<3<<endl;

    myfile<<3<<endl;

    //myfile<<3<<endl;

    myfile<<"POINT_DATA "<<vertices.size()<<"\n";    
    myfile<<"SCALARS radius double "<<"\n";  

    myfile<<"LOOKUP_TABLE default\n";

    myfile<<"0.0\n";
    myfile<<"1.0\n";
    myfile<<"1.0\n";
    myfile<<"1.0\n";
    myfile<<"0.0\n";
    myfile<<"0.0\n";
    myfile<<"0.0\n";

    myfile.close();
  }

  void CVtkWriter::readVTKParticles(std::string fileName, std::vector< VECTOR3 >& position, std::vector< Real >& density, std::vector< Real >& radii)
  {

    using namespace std;
    ifstream myfile(fileName);

    //check
    if(!myfile.is_open())
    {
      cout<<"Error opening file: "<<fileName<<endl;
      exit(1);
    }//end if

    char line[1024];

    string word;

    myfile>>word;

    while(word != string("POINTS"))
    {
      myfile.getline(line,1024);
      myfile>>word;
    }

    int nPoints;
    myfile >> nPoints;

    myfile.getline(line,1024);

    int count=0;

    while(myfile.good() && count < nPoints)
    {
      if(myfile.peek() != '\n')
      {
        VECTOR3 vec;
        myfile>>vec.x>>vec.y>>vec.z;
        position.push_back(vec);
        count++;
      }
      else
        myfile.getline(line,1024);
    }

    while(myfile.good())
    {
      myfile>>word;

      if(word == string("radii"))
      {
        myfile.getline(line,1024);
        count=0;

        while(myfile.good() && count < nPoints)
        {
          if(myfile.peek() != '\n')
          {
            Real rad;
            myfile>>rad;
            radii.push_back(rad);
            count++;
          }
          else
            myfile.getline(line,1024);
        }
      }
      else if(word == string("density"))
      {
        myfile.getline(line,1024);
        count=0;

        while(myfile.good() && count < nPoints)
        {
          if(myfile.peek() != '\n')
          {
            Real d;
            myfile>>d;
            density.push_back(d);
            count++;
          }
          else
            myfile.getline(line,1024);
        }
      }
      else
        myfile.getline(line,1024);

    }

    myfile.close();

  }

}
