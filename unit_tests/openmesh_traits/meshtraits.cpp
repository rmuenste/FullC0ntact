#include <cstdlib>
#include <vector>
#include <algorithm>
#include <iostream>

#include <OpenMesh/Core/IO/MeshIO.hh>
#include <OpenMesh/Core/Mesh/TriMesh_ArrayKernelT.hh>
#include <OpenMesh/Core/Geometry/VectorT.hh>

struct MyTraits : OpenMesh::DefaultTraits {
  // Point and Normal
  typedef OpenMesh::Vec3d Point;
  typedef OpenMesh::Vec3d Normal;

  // Define VertexTraits
  VertexTraits{

    private:
      Point cog_;
      int originalIdx_;

    public:
      VertexT() : cog_(Point(0.0f, 0.0f, 0.0f)), originalIdx_(-1), extruded(false) {}

      const Point& cog() const { return cog_; }

      void set_cog(const Point& p) { cog_ = p; }

      void set_orig_idx(int i) { originalIdx_ = i; }

      int get_orig_idx() const { return originalIdx_; }

      bool extruded;

  };
};

typedef OpenMesh::TriMesh_ArrayKernelT<MyTraits> MyMesh;
typedef double ScalarType;

void WriteUnstr(std::vector<MyMesh*> &layers, const char *strFileName)
{

  using namespace std;
  FILE * myfile = fopen(strFileName,"w");

  if (myfile == NULL) {
    cout<<"Error opening file: "<<strFileName<<endl;
    exit(0);
  }  

  int verts = layers[0]->n_vertices();
  int totalVertices = layers.size() * layers[0]->n_vertices();

  int i;
  fprintf(myfile,"# vtk DataFile Version 2.0\n");
  fprintf(myfile,"Generated by FullC0ntact\n");
  fprintf(myfile,"ASCII\n");
  fprintf(myfile,"DATASET UNSTRUCTURED_GRID\n");
  fprintf(myfile,"POINTS %i double\n", totalVertices);      

  typedef MyMesh::VertexIter Viter;
  for(auto &mesh : layers)
  {
    for (Viter v_it = mesh->vertices_begin(); v_it != mesh->vertices_end(); ++v_it) {
      fprintf(myfile,"%f %f %f \n", mesh->point(*v_it)[0], mesh->point(*v_it)[1], mesh->point(*v_it)[2]);    
    }
  }//end for

  int nfaces = (layers.size() - 1) * layers[0]->n_faces();

  fprintf(myfile,"CELLS %i %i\n",nfaces,nfaces*7);
  //fprintf(myfile,"CELLS %i %i\n",1,7);
  
//  fprintf(myfile,"6  %i %i %i %i %i %i\n",0, 1, 2, verts, verts+1, verts+2);
  for (int ilayers = 1; ilayers < layers.size(); ++ilayers)
  {
    auto mesh = layers[ilayers-1];
    auto mesh1 = layers[ilayers];
    for (auto f_it = mesh->faces_begin(), f_it2 = mesh1->faces_begin(); f_it != mesh->faces_end(); ++f_it, ++f_it2) {
      auto fv_it = mesh->fv_iter(*f_it);

      std::vector<int> face1;

      for (; fv_it.is_valid(); ++fv_it) {
        int idx = (*fv_it).idx();
        face1.push_back(idx);
      }

      std::vector<int> face2;
      fv_it = mesh1->fv_iter(*f_it2);

      for (; fv_it.is_valid(); ++fv_it) {
        int idx = (*fv_it).idx();
        face2.push_back(idx);
      }

      int i0 = face1[0] + (ilayers - 1) * verts;
      int i1 = face1[1] + (ilayers - 1) * verts;
      int i2 = face1[2] + (ilayers - 1) * verts;
      int i3 = face2[0] + (ilayers) * verts;
      int i4 = face2[1] + (ilayers) * verts;
      int i5 = face2[2] + (ilayers) * verts;
      fprintf(myfile, "6  %i %i %i %i %i %i\n", i0, i1, i2, i3, i4, i5);

    }
  }

  fprintf(myfile,"CELL_TYPES %i\n",nfaces);        
  for(i=0;i<nfaces;i++)
  {
    fprintf(myfile,"13\n");          
  }//end for

  //close the file
  fclose (myfile);  

}

void writeOFFMesh(MyMesh& mesh, std::string fileName) {

  try {
    if (!OpenMesh::IO::write_mesh(mesh, fileName)) {
      std::cerr << "Cannot write mesh to file '"<< fileName << "'" << std::endl;
      std::exit(EXIT_FAILURE);
    }
  }
  catch( std::exception &x) {
    std::cerr << x.what() << std::endl;
    std::exit(EXIT_FAILURE);
  }

}

MyMesh readMesh() {
  MyMesh mesh;

  if (typeid(OpenMesh::vector_traits<MyMesh::Point>::value_type) != typeid(double)) {
    std::cerr << "Data type error" << std::endl;
    std::exit(EXIT_FAILURE);
  }

  if (typeid(OpenMesh::vector_traits<MyMesh::Normal>::value_type) != typeid(double)) {
    std::cerr << "Data type error" << std::endl;
    std::exit(EXIT_FAILURE);
  }

  mesh.request_vertex_normals();
  mesh.request_face_normals();

  OpenMesh::IO::Options opt;

  if (!OpenMesh::IO::read_mesh(mesh, "input.off", opt)) {
    std::cerr << "Error: cannot read from file ico_sphere.off" << std::endl;
    std::exit(EXIT_FAILURE);
  }

  if (!opt.check(OpenMesh::IO::Options::VertexNormal) && mesh.has_face_normals() && mesh.has_vertex_normals()) {
    mesh.update_normals();
  }

  return mesh;
}

void scaleAlongNormal(MyMesh& mesh, ScalarType dist) {
  typedef MyMesh::VertexIter Viter;
  for (Viter v_it = mesh.vertices_begin(); v_it != mesh.vertices_end(); ++v_it) {
    //std::cout << "Vertex #" << *v_it << ": " << mesh.point(*v_it);
    mesh.set_point(*v_it, mesh.point(*v_it) + dist * mesh.normal(*v_it));
    //std::cout << "moved to " << mesh.point( *v_it ) << std::endl;
  }
    std::cout << "Moving finished" << std::endl;
}

MyMesh getScaledMesh(MyMesh& mesh, ScalarType dist) {

  typedef MyMesh::VertexIter Viter;
  MyMesh extMesh;

  extMesh = mesh;
  scaleAlongNormal(extMesh, dist);

//  MyMesh::Point vertices[] = {
//    MyMesh::Point(-1, -1, 1), 
//    MyMesh::Point( 1, -1, 1),
//    MyMesh::Point( 1,  1, 1),
//    MyMesh::Point(-1,  1, 1),
//    MyMesh::Point(-1, -1,-1),
//    MyMesh::Point( 1, -1,-1),
//    MyMesh::Point( 1,  1,-1),
//    MyMesh::Point(-1,  1,-1)
//  };
//  
//  MyMesh::VertexHandle vhandle[8];
//
//  int connectivity[][4] = { {0, 1, 2, 3}, {7, 6, 5, 4}, {1, 0, 4, 5}, {2, 1, 5, 6}, {3, 2, 6, 7}, {0, 3, 7, 4} };

  std::vector<MyMesh::VertexHandle> vhandle;
  std::vector<MyMesh::Point> vertices;
  std::vector<MyMesh::VertexHandle> face_vhandles;

//  for (unsigned i(0); i < 8; ++i) {
//    vhandle[i] = mesh.add_vertex(vertices[i]);
//  }

//  for (unsigned i(0); i < 8; ++i) {
//    vhandle[i] = mesh.add_vertex(vertices[i]);
//  }
//
//  std::vector<MyMesh::VertexHandle> face_vhandles;
//
//  for (unsigned i(0); i < 6; ++i) {
//    face_vhandles.clear();
//    face_vhandles.push_back(vhandle[connectivity[i][0]]);
//    face_vhandles.push_back(vhandle[connectivity[i][1]]);
//    face_vhandles.push_back(vhandle[connectivity[i][2]]);
//    face_vhandles.push_back(vhandle[connectivity[i][3]]);
//    mesh.add_face(face_vhandles);
//  }

//  for (Viter v_it = mesh.vertices_begin(); v_it != mesh.vertices_end(); ++v_it) {
//    //mesh.set_point(*v_it, mesh.point(*v_it) + dist * mesh.normal(*v_it));
//    MyMesh::Point p = mesh.point(*v_it) * dist * mesh.normal(*v_it);
//    //std::cout << "Vertex #" << *v_it << ": " << mesh.point(*v_it) << std::endl;
//    vhandle.push_back(extMesh.add_vertex(p));
//  }
//  std::cout << "Moving finished" << std::endl;

//  std::cout << "Adding faces" << std::endl;
//
//  for (auto f_it = mesh.faces_begin(); f_it != mesh.faces_end(); ++f_it) {
//    auto fv_it = mesh.fv_iter(*f_it);
//    face_vhandles.clear();
//    for (; fv_it.is_valid(); ++fv_it) {
//      int idx = (*fv_it).idx();
//      face_vhandles.push_back(vhandle[idx]);
//    }
//    extMesh.add_face(face_vhandles);
//  }
//
//  extMesh.request_vertex_normals();
//  extMesh.request_face_normals();
//  extMesh.update_normals();

  return extMesh;
}

int main()
{
  MyMesh mesh = readMesh();

  std::vector<MyMesh*> meshLayers;
  meshLayers.push_back(&mesh);

  ScalarType ex = 0.00025;

  MyMesh layer1 = getScaledMesh(mesh, ex);
  MyMesh layer2 = getScaledMesh(layer1, ex);
  MyMesh layer3 = getScaledMesh(layer2, ex);

  meshLayers.push_back(&layer1);
  meshLayers.push_back(&layer2);
  meshLayers.push_back(&layer3);

  WriteUnstr(meshLayers, "wedges.vtk");

//  writeOFFMesh(layer1, "extMesh.stl");
//  writeOFFMesh(mesh, "origMesh.stl");

  return EXIT_SUCCESS;
}
